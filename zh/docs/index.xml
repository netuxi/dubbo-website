<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 文档</title><link>/zh/docs/</link><description>Recent content in 文档 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/zh/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Dubbo SPI</title><link>/zh/docs/v2.7/dev/source/dubbo-spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/source/dubbo-spi/</guid><description>
&lt;h2 id="1简介">1.简介&lt;/h2>
&lt;p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。&lt;/p>
&lt;p>需要特别说明的是，本篇文章以及本系列其他文章所分析的源码版本均为 &lt;strong>dubbo-2.6.4&lt;/strong>。因此大家在阅读文章的过程中，需注意将代码版本切换到 dubbo-2.6.4 tag 上。&lt;/p>
&lt;h2 id="2spi-示例">2.SPI 示例&lt;/h2>
&lt;h3 id="21--java-spi-示例">2.1 Java SPI 示例&lt;/h3>
&lt;p>前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Robot&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">OptimusPrime&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Robot &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Hello, I am Optimus Prime.&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Bumblebee&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Robot &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Hello, I am Bumblebee.&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">org.apache.spi.OptimusPrime
org.apache.spi.Bumblebee
&lt;/code>&lt;/pre>&lt;/div>&lt;p>做好所需的准备工作，接下来编写代码进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">JavaSPITest&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Test&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> Exception &lt;span style="color:#719e07">{&lt;/span>
ServiceLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>Robot&lt;span style="color:#719e07">&amp;gt;&lt;/span> serviceLoader &lt;span style="color:#719e07">=&lt;/span> ServiceLoader&lt;span style="color:#719e07">.&lt;/span>load&lt;span style="color:#719e07">(&lt;/span>Robot&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Java SPI&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
serviceLoader&lt;span style="color:#719e07">.&lt;/span>forEach&lt;span style="color:#719e07">(&lt;/span>Robot&lt;span style="color:#719e07">::&lt;/span>sayHello&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后来看一下测试结果，如下：&lt;/p>
&lt;p>&lt;img src="/imgs/dev/java-spi-result.jpg" alt="">&lt;/p>
&lt;p>从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。关于 Java SPI 的演示先到这里，接下来演示 Dubbo SPI。&lt;/p>
&lt;h3 id="22-dubbo-spi-示例">2.2 Dubbo SPI 示例&lt;/h3>
&lt;p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">optimusPrime = org.apache.spi.OptimusPrime
bumblebee = org.apache.spi.Bumblebee
&lt;/code>&lt;/pre>&lt;/div>&lt;p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DubboSPITest&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Test&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> Exception &lt;span style="color:#719e07">{&lt;/span>
ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>Robot&lt;span style="color:#719e07">&amp;gt;&lt;/span> extensionLoader &lt;span style="color:#719e07">=&lt;/span>
ExtensionLoader&lt;span style="color:#719e07">.&lt;/span>getExtensionLoader&lt;span style="color:#719e07">(&lt;/span>Robot&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
Robot optimusPrime &lt;span style="color:#719e07">=&lt;/span> extensionLoader&lt;span style="color:#719e07">.&lt;/span>getExtension&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;optimusPrime&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
optimusPrime&lt;span style="color:#719e07">.&lt;/span>sayHello&lt;span style="color:#719e07">();&lt;/span>
Robot bumblebee &lt;span style="color:#719e07">=&lt;/span> extensionLoader&lt;span style="color:#719e07">.&lt;/span>getExtension&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;bumblebee&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
bumblebee&lt;span style="color:#719e07">.&lt;/span>sayHello&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试结果如下：&lt;/p>
&lt;p>&lt;img src="/imgs/dev/dubbo-spi-result.jpg" alt="">&lt;/p>
&lt;p>Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性，这些特性将会在接下来的源码分析章节中一一进行介绍。&lt;/p>
&lt;h2 id="3-dubbo-spi-源码分析">3. Dubbo SPI 源码分析&lt;/h2>
&lt;p>上一章简单演示了 Dubbo SPI 的使用方法。我们首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。该方法的逻辑比较简单，本章就不进行分析了。下面我们从 ExtensionLoader 的 getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">getExtension&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String name&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>name &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> name&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Extension name == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取默认的拓展实现类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> getDefaultExtension&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// Holder，顾名思义，用于持有目标对象
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Holder&lt;span style="color:#719e07">&amp;lt;&lt;/span>Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> holder &lt;span style="color:#719e07">=&lt;/span> cachedInstances&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>holder &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
cachedInstances&lt;span style="color:#719e07">.&lt;/span>putIfAbsent&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Holder&lt;span style="color:#719e07">&amp;lt;&lt;/span>Object&lt;span style="color:#719e07">&amp;gt;());&lt;/span>
holder &lt;span style="color:#719e07">=&lt;/span> cachedInstances&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
Object instance &lt;span style="color:#719e07">=&lt;/span> holder&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 双重检查
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#719e07">(&lt;/span>holder&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
instance &lt;span style="color:#719e07">=&lt;/span> holder&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 创建拓展实例
&lt;/span>&lt;span style="color:#586e75">&lt;/span> instance &lt;span style="color:#719e07">=&lt;/span> createExtension&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 设置实例到 holder 中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> holder&lt;span style="color:#719e07">.&lt;/span>set&lt;span style="color:#719e07">(&lt;/span>instance&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">(&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> instance&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码的逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。下面我们来看一下创建拓展对象的过程是怎样的。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> T &lt;span style="color:#268bd2">createExtension&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String name&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz &lt;span style="color:#719e07">=&lt;/span> getExtensionClasses&lt;span style="color:#719e07">().&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>clazz &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> findException&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
T instance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">(&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> EXTENSION_INSTANCES&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 通过反射创建实例
&lt;/span>&lt;span style="color:#586e75">&lt;/span> EXTENSION_INSTANCES&lt;span style="color:#719e07">.&lt;/span>putIfAbsent&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">,&lt;/span> clazz&lt;span style="color:#719e07">.&lt;/span>newInstance&lt;span style="color:#719e07">());&lt;/span>
instance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">(&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> EXTENSION_INSTANCES&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 向实例中注入依赖
&lt;/span>&lt;span style="color:#586e75">&lt;/span> injectExtension&lt;span style="color:#719e07">(&lt;/span>instance&lt;span style="color:#719e07">);&lt;/span>
Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> wrapperClasses &lt;span style="color:#719e07">=&lt;/span> cachedWrapperClasses&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>wrapperClasses &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>wrapperClasses&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 循环创建 Wrapper 实例
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> wrapperClass &lt;span style="color:#719e07">:&lt;/span> wrapperClasses&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量
&lt;/span>&lt;span style="color:#586e75">&lt;/span> instance &lt;span style="color:#719e07">=&lt;/span> injectExtension&lt;span style="color:#719e07">(&lt;/span>
&lt;span style="color:#719e07">(&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> wrapperClass&lt;span style="color:#719e07">.&lt;/span>getConstructor&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">).&lt;/span>newInstance&lt;span style="color:#719e07">(&lt;/span>instance&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> instance&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：&lt;/p>
&lt;ol>
&lt;li>通过 getExtensionClasses 获取所有的拓展类&lt;/li>
&lt;li>通过反射创建拓展对象&lt;/li>
&lt;li>向拓展对象中注入依赖&lt;/li>
&lt;li>将拓展对象包裹在相应的 Wrapper 对象中&lt;/li>
&lt;/ol>
&lt;p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。在接下来的章节中，将会重点分析 getExtensionClasses 方法的逻辑，以及简单介绍 Dubbo IOC 的具体实现。&lt;/p>
&lt;h3 id="31-获取所有的拓展类">3.1 获取所有的拓展类&lt;/h3>
&lt;p>我们在通过名称获取拓展类之前，首先需要根据配置文件解析出拓展项名称到拓展类的映射关系表（Map&amp;lt;名称, 拓展类&amp;gt;），之后再根据拓展项名称从映射关系表中取出相应的拓展类即可。相关过程的代码分析如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> getExtensionClasses&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 从缓存中获取已加载的拓展类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> classes &lt;span style="color:#719e07">=&lt;/span> cachedClasses&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 双重检查
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>classes &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#719e07">(&lt;/span>cachedClasses&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
classes &lt;span style="color:#719e07">=&lt;/span> cachedClasses&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>classes &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 加载拓展类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> classes &lt;span style="color:#719e07">=&lt;/span> loadExtensionClasses&lt;span style="color:#719e07">();&lt;/span>
cachedClasses&lt;span style="color:#719e07">.&lt;/span>set&lt;span style="color:#719e07">(&lt;/span>classes&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> classes&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> loadExtensionClasses&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取 SPI 注解，这里的 type 变量是在调用 getExtensionLoader 方法时传入的
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> SPI defaultAnnotation &lt;span style="color:#719e07">=&lt;/span> type&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>SPI&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>defaultAnnotation &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String value &lt;span style="color:#719e07">=&lt;/span> defaultAnnotation&lt;span style="color:#719e07">.&lt;/span>value&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">((&lt;/span>value &lt;span style="color:#719e07">=&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>trim&lt;span style="color:#719e07">()).&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 对 SPI 注解内容进行切分
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String&lt;span style="color:#719e07">[]&lt;/span> names &lt;span style="color:#719e07">=&lt;/span> NAME_SEPARATOR&lt;span style="color:#719e07">.&lt;/span>split&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 检测 SPI 注解内容是否合法，不合法则抛出异常
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>names&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">&amp;gt;&lt;/span> 1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;more than 1 default extension name on extension...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 设置默认名称，参考 getDefaultExtension 方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>names&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">==&lt;/span> 1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
cachedDefaultName &lt;span style="color:#719e07">=&lt;/span> names&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">];&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;();&lt;/span>
&lt;span style="color:#586e75">// 加载指定文件夹下的配置文件
&lt;/span>&lt;span style="color:#586e75">&lt;/span> loadDirectory&lt;span style="color:#719e07">(&lt;/span>extensionClasses&lt;span style="color:#719e07">,&lt;/span> DUBBO_INTERNAL_DIRECTORY&lt;span style="color:#719e07">);&lt;/span>
loadDirectory&lt;span style="color:#719e07">(&lt;/span>extensionClasses&lt;span style="color:#719e07">,&lt;/span> DUBBO_DIRECTORY&lt;span style="color:#719e07">);&lt;/span>
loadDirectory&lt;span style="color:#719e07">(&lt;/span>extensionClasses&lt;span style="color:#719e07">,&lt;/span> SERVICES_DIRECTORY&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> extensionClasses&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。SPI 注解解析过程比较简单，无需多说。下面我们来看一下 loadDirectory 做了哪些事情。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadDirectory&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses&lt;span style="color:#719e07">,&lt;/span> String dir&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// fileName = 文件夹路径 + type 全限定名
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String fileName &lt;span style="color:#719e07">=&lt;/span> dir &lt;span style="color:#719e07">+&lt;/span> type&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Enumeration&lt;span style="color:#719e07">&amp;lt;&lt;/span>java&lt;span style="color:#719e07">.&lt;/span>net&lt;span style="color:#719e07">.&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> urls&lt;span style="color:#719e07">;&lt;/span>
ClassLoader classLoader &lt;span style="color:#719e07">=&lt;/span> findClassLoader&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 根据文件名加载所有的同名文件
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>classLoader &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
urls &lt;span style="color:#719e07">=&lt;/span> classLoader&lt;span style="color:#719e07">.&lt;/span>getResources&lt;span style="color:#719e07">(&lt;/span>fileName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
urls &lt;span style="color:#719e07">=&lt;/span> ClassLoader&lt;span style="color:#719e07">.&lt;/span>getSystemResources&lt;span style="color:#719e07">(&lt;/span>fileName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>urls &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">while&lt;/span> &lt;span style="color:#719e07">(&lt;/span>urls&lt;span style="color:#719e07">.&lt;/span>hasMoreElements&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
java&lt;span style="color:#719e07">.&lt;/span>net&lt;span style="color:#719e07">.&lt;/span>URL resourceURL &lt;span style="color:#719e07">=&lt;/span> urls&lt;span style="color:#719e07">.&lt;/span>nextElement&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 加载资源
&lt;/span>&lt;span style="color:#586e75">&lt;/span> loadResource&lt;span style="color:#719e07">(&lt;/span>extensionClasses&lt;span style="color:#719e07">,&lt;/span> classLoader&lt;span style="color:#719e07">,&lt;/span> resourceURL&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>error&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>loadDirectory 方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。我们继续跟下去，看一下 loadResource 方法的实现。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadResource&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses&lt;span style="color:#719e07">,&lt;/span>
ClassLoader classLoader&lt;span style="color:#719e07">,&lt;/span> java&lt;span style="color:#719e07">.&lt;/span>net&lt;span style="color:#719e07">.&lt;/span>URL resourceURL&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
BufferedReader reader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> BufferedReader&lt;span style="color:#719e07">(&lt;/span>
&lt;span style="color:#719e07">new&lt;/span> InputStreamReader&lt;span style="color:#719e07">(&lt;/span>resourceURL&lt;span style="color:#719e07">.&lt;/span>openStream&lt;span style="color:#719e07">(),&lt;/span> &lt;span style="color:#2aa198">&amp;#34;utf-8&amp;#34;&lt;/span>&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String line&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 按行读取配置内容
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">while&lt;/span> &lt;span style="color:#719e07">((&lt;/span>line &lt;span style="color:#719e07">=&lt;/span> reader&lt;span style="color:#719e07">.&lt;/span>readLine&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 定位 # 字符
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> ci &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>indexOf&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#39;#&amp;#39;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>ci &lt;span style="color:#719e07">&amp;gt;=&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略
&lt;/span>&lt;span style="color:#586e75">&lt;/span> line &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">,&lt;/span> ci&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
line &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>trim&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>line&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String name &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>indexOf&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#39;=&amp;#39;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 以等于号 = 为界，截取键与值
&lt;/span>&lt;span style="color:#586e75">&lt;/span> name &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">).&lt;/span>trim&lt;span style="color:#719e07">();&lt;/span>
line &lt;span style="color:#719e07">=&lt;/span> line&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">+&lt;/span> 1&lt;span style="color:#719e07">).&lt;/span>trim&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>line&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 加载类，并通过 loadClass 方法对类进行缓存
&lt;/span>&lt;span style="color:#586e75">&lt;/span> loadClass&lt;span style="color:#719e07">(&lt;/span>extensionClasses&lt;span style="color:#719e07">,&lt;/span> resourceURL&lt;span style="color:#719e07">,&lt;/span>
Class&lt;span style="color:#719e07">.&lt;/span>forName&lt;span style="color:#719e07">(&lt;/span>line&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">,&lt;/span> classLoader&lt;span style="color:#719e07">),&lt;/span> name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
IllegalStateException e &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Failed to load extension class...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">finally&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
reader&lt;span style="color:#719e07">.&lt;/span>close&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>error&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Exception when load extension class...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。loadClass 方法用于主要用于操作缓存，该方法的逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadClass&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses&lt;span style="color:#719e07">,&lt;/span> java&lt;span style="color:#719e07">.&lt;/span>net&lt;span style="color:#719e07">.&lt;/span>URL resourceURL&lt;span style="color:#719e07">,&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz&lt;span style="color:#719e07">,&lt;/span> String name&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> NoSuchMethodException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>type&lt;span style="color:#719e07">.&lt;/span>isAssignableFrom&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 检测目标类上是否有 Adaptive 注解
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">.&lt;/span>isAnnotationPresent&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>cachedAdaptiveClass &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 设置 cachedAdaptiveClass缓存
&lt;/span>&lt;span style="color:#586e75">&lt;/span> cachedAdaptiveClass &lt;span style="color:#719e07">=&lt;/span> clazz&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>cachedAdaptiveClass&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 检测 clazz 是否是 Wrapper 类型
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>isWrapperClass&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> wrappers &lt;span style="color:#719e07">=&lt;/span> cachedWrapperClasses&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>wrappers &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
cachedWrapperClasses &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashSet&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;();&lt;/span>
wrappers &lt;span style="color:#719e07">=&lt;/span> cachedWrapperClasses&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 存储 clazz 到 cachedWrapperClasses 缓存中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> wrappers&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 程序进入此分支，表明 clazz 是一个普通的拓展类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常
&lt;/span>&lt;span style="color:#586e75">&lt;/span> clazz&lt;span style="color:#719e07">.&lt;/span>getConstructor&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>name &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> name&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为 name
&lt;/span>&lt;span style="color:#586e75">&lt;/span> name &lt;span style="color:#719e07">=&lt;/span> findAnnotationName&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 切分 name
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String&lt;span style="color:#719e07">[]&lt;/span> names &lt;span style="color:#719e07">=&lt;/span> NAME_SEPARATOR&lt;span style="color:#719e07">.&lt;/span>split&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>names &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> names&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Activate activate &lt;span style="color:#719e07">=&lt;/span> clazz&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Activate&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>activate &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 存储 name 到 Activate 注解对象的映射关系
&lt;/span>&lt;span style="color:#586e75">&lt;/span> cachedActivates&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>names&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">],&lt;/span> activate&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String n &lt;span style="color:#719e07">:&lt;/span> names&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>cachedNames&lt;span style="color:#719e07">.&lt;/span>containsKey&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 存储 Class 到名称的映射关系
&lt;/span>&lt;span style="color:#586e75">&lt;/span> cachedNames&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>clazz&lt;span style="color:#719e07">,&lt;/span> n&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> c &lt;span style="color:#719e07">=&lt;/span> extensionClasses&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>n&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>c &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 存储名称到 Class 的映射关系
&lt;/span>&lt;span style="color:#586e75">&lt;/span> extensionClasses&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>n&lt;span style="color:#719e07">,&lt;/span> clazz&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>c &lt;span style="color:#719e07">!=&lt;/span> clazz&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，loadClass 方法操作了不同的缓存，比如 cachedAdaptiveClass、cachedWrapperClasses 和 cachedNames 等等。除此之外，该方法没有其他什么逻辑了。&lt;/p>
&lt;p>到此，关于缓存类加载的过程就分析完了。整个过程没什么特别复杂的地方，大家按部就班的分析即可，不懂的地方可以调试一下。接下来，我们来聊聊 Dubbo IOC 方面的内容。&lt;/p>
&lt;h3 id="32-dubbo-ioc">3.2 Dubbo IOC&lt;/h3>
&lt;p>Dubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> T &lt;span style="color:#268bd2">injectExtension&lt;/span>&lt;span style="color:#719e07">(&lt;/span>T instance&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>objectFactory &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 遍历目标类的所有方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> instance&lt;span style="color:#719e07">.&lt;/span>getClass&lt;span style="color:#719e07">().&lt;/span>getMethods&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">().&lt;/span>startsWith&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;set&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">().&lt;/span>length &lt;span style="color:#719e07">==&lt;/span> 1
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> Modifier&lt;span style="color:#719e07">.&lt;/span>isPublic&lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">.&lt;/span>getModifiers&lt;span style="color:#719e07">()))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取 setter 方法参数类型
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> pt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">()[&lt;/span>0&lt;span style="color:#719e07">];&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取属性名，比如 setName 方法对应属性名 name
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String property &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">().&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;gt;&lt;/span> 3 &lt;span style="color:#719e07">?&lt;/span>
method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">().&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>3&lt;span style="color:#719e07">,&lt;/span> 4&lt;span style="color:#719e07">).&lt;/span>toLowerCase&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">().&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>4&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 从 ObjectFactory 中获取依赖对象
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Object object &lt;span style="color:#719e07">=&lt;/span> objectFactory&lt;span style="color:#719e07">.&lt;/span>getExtension&lt;span style="color:#719e07">(&lt;/span>pt&lt;span style="color:#719e07">,&lt;/span> property&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>object &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 通过反射调用 setter 方法设置依赖
&lt;/span>&lt;span style="color:#586e75">&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>invoke&lt;span style="color:#719e07">(&lt;/span>instance&lt;span style="color:#719e07">,&lt;/span> object&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Exception e&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>error&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;fail to inject via method...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Exception e&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>error&lt;span style="color:#719e07">(&lt;/span>e&lt;span style="color:#719e07">.&lt;/span>getMessage&lt;span style="color:#719e07">(),&lt;/span> e&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> instance&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。&lt;/p>
&lt;p>Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。&lt;/p>
&lt;h2 id="4总结">4.总结&lt;/h2>
&lt;p>本篇文章简单分别介绍了 Java SPI 与 Dubbo SPI 用法，并对 Dubbo SPI 的加载拓展类的过程进行了分析。另外，在 Dubbo SPI 中还有一块重要的逻辑这里没有进行分析，即 Dubbo SPI 的扩展点自适应机制。该机制的逻辑较为复杂，我们将会在下一篇文章中进行详细的分析。&lt;/p>
&lt;p>好了，本篇文章就先到这里了。如果文章中有错误不妥之处，欢迎大家提 issue 进行反馈，或者提 pull request 进行修正。让我们携手共建 Dubbo 社区。&lt;/p></description></item><item><title>Docs: dubbo 协议</title><link>/zh/docs/v2.7/user/references/protocol/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/protocol/dubbo/</guid><description>
&lt;p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。&lt;/p>
&lt;p>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。&lt;/p>
&lt;p>&lt;img src="/imgs/user/dubbo-protocol.jpg" alt="dubbo-protocol.jpg">&lt;/p>
&lt;ul>
&lt;li>Transporter: mina, netty, grizzy&lt;/li>
&lt;li>Serialization: dubbo, hessian2, java, json&lt;/li>
&lt;li>Dispatcher: all, direct, message, execution, connection&lt;/li>
&lt;li>ThreadPool: fixed, cached&lt;/li>
&lt;/ul>
&lt;h2 id="特性">特性&lt;/h2>
&lt;p>缺省协议，使用基于 mina &lt;code>1.1.7&lt;/code> 和 hessian &lt;code>3.2.1&lt;/code> 的 tbremoting 交互。&lt;/p>
&lt;ul>
&lt;li>连接个数：单连接&lt;/li>
&lt;li>连接方式：长连接&lt;/li>
&lt;li>传输协议：TCP&lt;/li>
&lt;li>传输方式：NIO 异步传输&lt;/li>
&lt;li>序列化：Hessian 二进制序列化&lt;/li>
&lt;li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。&lt;/li>
&lt;li>适用场景：常规远程服务方法调用&lt;/li>
&lt;/ul>
&lt;h2 id="约束">约束&lt;/h2>
&lt;ul>
&lt;li>参数及返回值需实现 &lt;code>Serializable&lt;/code> 接口&lt;/li>
&lt;li>参数及返回值不能自定义实现 &lt;code>List&lt;/code>, &lt;code>Map&lt;/code>, &lt;code>Number&lt;/code>, &lt;code>Date&lt;/code>, &lt;code>Calendar&lt;/code> 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。&lt;/li>
&lt;li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据通讯&lt;/th>
&lt;th>情况&lt;/th>
&lt;th>结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A-&amp;gt;B&lt;/td>
&lt;td>类A多一种 属性（或者说类B少一种 属性）&lt;/td>
&lt;td>不抛异常，A多的那 个属性的值，B没有， 其他正常&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A-&amp;gt;B&lt;/td>
&lt;td>枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输&lt;/td>
&lt;td>抛异常&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A-&amp;gt;B&lt;/td>
&lt;td>枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输&lt;/td>
&lt;td>不抛异常，B正常接 收数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A-&amp;gt;B&lt;/td>
&lt;td>A和B的属性 名相同，但类型不相同&lt;/td>
&lt;td>抛异常&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A-&amp;gt;B&lt;/td>
&lt;td>serialId 不相同&lt;/td>
&lt;td>正常传输&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。&lt;/p>
&lt;p>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。&lt;/p>
&lt;p>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>配置协议：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置默认协议：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:provider&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置服务协议：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多端口：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;dubbo1&amp;#34;&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;dubbo2&amp;#34;&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;20881&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置协议选项：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">“dubbo”&lt;/span> port=&lt;span style="color:#2aa198">“9090”&lt;/span> server=&lt;span style="color:#2aa198">“netty”&lt;/span> client=&lt;span style="color:#2aa198">“netty”&lt;/span> codec=&lt;span style="color:#2aa198">“dubbo”&lt;/span> serialization=&lt;span style="color:#2aa198">“hessian2”&lt;/span> charset=&lt;span style="color:#2aa198">“UTF-8”&lt;/span> threadpool=&lt;span style="color:#2aa198">“fixed”&lt;/span> threads=&lt;span style="color:#2aa198">“100”&lt;/span> queues=&lt;span style="color:#2aa198">“0”&lt;/span> iothreads=&lt;span style="color:#2aa198">“9”&lt;/span> buffer=&lt;span style="color:#2aa198">“8192”&lt;/span> accepts=&lt;span style="color:#2aa198">“1000”&lt;/span> payload=&lt;span style="color:#2aa198">“8388608”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多连接配置：&lt;/p>
&lt;p>Dubbo 协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> connections=&lt;span style="color:#2aa198">&amp;#34;1&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> connections=&lt;span style="color:#2aa198">&amp;#34;1&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>&amp;lt;dubbo:service connections=&amp;quot;0&amp;quot;&amp;gt;&lt;/code> 或 &lt;code>&amp;lt;dubbo:reference connections=&amp;quot;0&amp;quot;&amp;gt;&lt;/code> 表示该服务使用 JVM 共享长连接。&lt;strong>缺省&lt;/strong>&lt;/li>
&lt;li>&lt;code>&amp;lt;dubbo:service connections=&amp;quot;1&amp;quot;&amp;gt;&lt;/code> 或 &lt;code>&amp;lt;dubbo:reference connections=&amp;quot;1&amp;quot;&amp;gt;&lt;/code> 表示该服务使用独立长连接。&lt;/li>
&lt;li>&lt;code>&amp;lt;dubbo:service connections=&amp;quot;2&amp;quot;&amp;gt;&lt;/code> 或&lt;code>&amp;lt;dubbo:reference connections=&amp;quot;2&amp;quot;&amp;gt;&lt;/code> 表示该服务使用独立两条长连接。&lt;/li>
&lt;/ul>
&lt;p>为防止被大量连接撑挂，可在服务提供方限制大接收连接数，以实现服务提供方自我保护。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> accepts=&lt;span style="color:#2aa198">&amp;#34;1000&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>dubbo.properties&lt;/code> 配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">dubbo.service.protocol&lt;span style="color:#719e07">=&lt;/span>dubbo
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h4 id="为什么要消费者比提供者个数多">为什么要消费者比提供者个数多?&lt;/h4>
&lt;p>因 dubbo 协议采用单一长连接，假设网络为千兆网卡 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。&lt;/p>
&lt;h4 id="为什么不能传大包">为什么不能传大包?&lt;/h4>
&lt;p>因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。&lt;/p>
&lt;h4 id="为什么采用异步单一长连接">为什么采用异步单一长连接?&lt;/h4>
&lt;p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>由吴亚军提供 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>总结：会抛异常的情况：枚举值一边多一种，一边少一种，正好使用了差别的那种，或者属性名相同，类型不同 &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>1024Mbit=128MByte &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: dubbo:application</title><link>/zh/docs/v2.7/user/references/xml/dubbo-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-application/</guid><description>
&lt;p>应用信息配置。对应的配置类：&lt;code>org.apache.dubbo.config.ApplicationConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>application&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>application.version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用的版本&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>organization&lt;/td>
&lt;td>organization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>architecture &lt;br class="atl-forced-newline" />&lt;/td>
&lt;td>architecture &lt;br class="atl-forced-newline" />&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>environment&lt;/td>
&lt;td>environment&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>compiler&lt;/td>
&lt;td>compiler&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>Java字节码编译器，用于动态类的生成，可选：jdk或javassist&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>logger&lt;/td>
&lt;td>logger&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>slf4j&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>日志输出方式，可选：slf4j,jcl,log4j,log4j2,jdk&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:argument</title><link>/zh/docs/v2.7/user/references/xml/dubbo-argument/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-argument/</guid><description>
&lt;p>方法参数配置。对应的配置类： &lt;code>org.apache.dubbo.config.ArgumentConfig&lt;/code>。该标签为 &lt;code>&amp;lt;dubbo:method&amp;gt;&lt;/code> 的子标签，用于方法参数的特征描述，比如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:method&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;findXxx&amp;#34;&lt;/span> timeout=&lt;span style="color:#2aa198">&amp;#34;3000&amp;#34;&lt;/span> retries=&lt;span style="color:#2aa198">&amp;#34;2&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:argument&lt;/span> index=&lt;span style="color:#2aa198">&amp;#34;0&amp;#34;&lt;/span> callback=&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:method&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>index&lt;/td>
&lt;td>&lt;/td>
&lt;td>int&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>标识&lt;/td>
&lt;td>参数索引&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>type&lt;/td>
&lt;td>&lt;/td>
&lt;td>String&lt;/td>
&lt;td>与index二选一&lt;/td>
&lt;td>&lt;/td>
&lt;td>标识&lt;/td>
&lt;td>通过参数类型查找参数的index&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>callback&lt;/td>
&lt;td>&amp;lt;metodName&amp;gt;&amp;lt;index&amp;gt;.retries&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>参数是否为callback接口，如果为callback，服务提供方将生成反向代理，可以从服务提供方反向调用消费方，通常用于事件推送.&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:config-center</title><link>/zh/docs/v2.7/user/references/xml/dubbo-config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-config-center/</guid><description>
&lt;p>配置中心。对应的配置类：&lt;code>org.apache.dubbo.config.ConfigCenterConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>config.protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>zookeeper&lt;/td>
&lt;td>使用哪个配置中心：apollo、zookeeper、nacos等。&lt;br />以zookeeper为例&lt;br />1. 指定protocol，则address可以简化为&lt;code>127.0.0.1:2181&lt;/code>；&lt;br />2. 不指定protocol，则address取值为&lt;code>zookeeper://127.0.0.1:2181&lt;/code>&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>config.address&lt;/td>
&lt;td>string&lt;/td>
&lt;td>必填&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置中心地址。&lt;br />取值参见protocol说明&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>highest-priority&lt;/td>
&lt;td>config.highestPriority&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>来自配置中心的配置项具有最高优先级，即会覆盖本地配置项。&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>namespace&lt;/td>
&lt;td>config.namespace&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>通常用于多租户隔离，实际含义视具体配置中心而不同。&lt;br />如：&lt;br />zookeeper - 环境隔离，默认值&lt;code>dubbo&lt;/code>；&lt;br />apollo - 区分不同领域的配置集合，默认使用&lt;code>dubbo&lt;/code>和&lt;code>application&lt;/code>&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>config.cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>含义视所选定的配置中心而不同。&lt;br />如Apollo中用来区分不同的配置集群&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>config.group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>含义视所选定的配置中心而不同。&lt;br />nacos - 隔离不同配置集&lt;br />zookeeper - 隔离不同配置集&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>config.check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>当配置中心连接失败时，是否终止应用启动。&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>config-file&lt;/td>
&lt;td>config.configFile&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo.properties&lt;/td>
&lt;td>全局级配置文件所映射到的key&lt;br />zookeeper - 默认路径/dubbo/config/dubbo/dubbo.properties&lt;br />apollo - dubbo namespace中的dubbo.properties键&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>config.timeout&lt;/td>
&lt;td>integer&lt;/td>
&lt;td>&lt;/td>
&lt;td>3000ms&lt;/td>
&lt;td>获取配置的超时时间&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>username&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>如果配置中心需要做校验，用户名&lt;br />Apollo暂未启用&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>password&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>如果配置中心需要做校验，密码&lt;br />Apollo暂未启用&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameters&lt;/td>
&lt;td>&lt;/td>
&lt;td>Map&amp;lt;string, string&amp;gt;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>扩展参数，用来支持不同配置中心的定制化配置参数&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>include-spring-env&lt;/td>
&lt;td>&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>使用Spring框架时支持，为true时，会自动从Spring Environment中读取配置。&lt;br />默认依次读取&lt;br />key为dubbo.properties的配置&lt;br />key为dubbo.properties的PropertySource&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:consumer</title><link>/zh/docs/v2.7/user/references/xml/dubbo-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-consumer/</guid><description>
&lt;p>服务消费者缺省值配置。配置类： &lt;code>org.apache.dubbo.config.ConsumerConfig&lt;/code> 。同时该标签为 &lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code> 标签的缺省值设置。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>default.timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用超时时间(毫秒)&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>default.retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>2&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0,仅在cluster为failback/failover时有效&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>default.loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>random&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>default.async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>default.connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>100&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每个服务对每个提供者的最大连接数，rmi、http、hessian等短连接协议支持此配置，dubbo协议长连接不支持此配置&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>generic&lt;/td>
&lt;td>generic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否缺省泛化接口，如果为泛化接口，将返回GenericService&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>启动时检查提供者是否存在，true报错，false忽略&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>生成动态代理方式，可选：jdk/javassist&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>调用服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>actives&lt;/td>
&lt;td>default.actives&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务消费者每服务每方法最大并发调用数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>default.cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>reference.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>invoker.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方引用服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省向所有registry注册&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>向指定注册中心注册，在多个注册中心时使用，值为&amp;lt;dubbo:registry&amp;gt;的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务调用者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>init&lt;/td>
&lt;td>init&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否在afterPropertiesSet()时饥饿初始化引用，否则等到有人注入或引用该实例时再初始化。&lt;/td>
&lt;td>2.0.10以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cache&lt;/td>
&lt;td>cache&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>以调用参数为key，缓存返回结果，可选：lru, threadlocal, jcache等&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>validation&lt;/td>
&lt;td>validation&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否启用JSR303标准注解验证，如果启用，将对方法参数上的注解进行校验&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:method</title><link>/zh/docs/v2.7/user/references/xml/dubbo-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-method/</guid><description>
&lt;p>方法级配置。对应的配置类： &lt;code>org.apache.dubbo.config.MethodConfig&lt;/code>。同时该标签为 &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> 或 &lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code> 的子标签，用于控制到方法级。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>标识&lt;/td>
&lt;td>方法名&lt;/td>
&lt;td>1.0.8以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为的timeout&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>方法调用超时时间(毫秒)&lt;/td>
&lt;td>1.0.8以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为&amp;lt;dubbo:reference&amp;gt;的retries&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为的loadbalance&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为&amp;lt;dubbo:reference&amp;gt;的async&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>1.0.9以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sent&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.sent&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>异步调用时，标记sent=true时，表示网络已发出数据&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>actives&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.actives&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务消费者最大并发调用限制&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>executes&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.executes&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务每方法最大使用线程数限制- -，此属性只在&amp;lt;dubbo:method&amp;gt;作为&amp;lt;dubbo:service&amp;gt;子标签时有效&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deprecated&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.deprecated&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务方法是否过时，此属性只在&amp;lt;dubbo:method&amp;gt;作为&amp;lt;dubbo:service&amp;gt;子标签时有效&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sticky&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.sticky&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设置true 该接口上的所有方法使用同一个provider.如果需要更复杂的规则，请使用用路由&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>return&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.return&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>方法调用是否需要返回值,async设置为true时才生效，如果设置为true，则返回future，或回调onreturn等方法，如果设置为false，则请求发送成功后直接返回Null&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>oninvoke&lt;/td>
&lt;td>attribute属性，不在URL中体现&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>方法执行前拦截&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>onreturn&lt;/td>
&lt;td>attribute属性，不在URL中体现&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>方法执行返回后拦截&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>onthrow&lt;/td>
&lt;td>attribute属性，不在URL中体现&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>方法执行有异常拦截&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cache&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.cache&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>以调用参数为key，缓存返回结果，可选：lru, threadlocal, jcache等&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>validation&lt;/td>
&lt;td>&amp;lt;methodName&amp;gt;.validation&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否启用JSR303标准注解验证，如果启用，将对方法参数上的注解进行校验&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>比如:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.xxx.XxxService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:method&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;findXxx&amp;#34;&lt;/span> timeout=&lt;span style="color:#2aa198">&amp;#34;3000&amp;#34;&lt;/span> retries=&lt;span style="color:#2aa198">&amp;#34;2&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:reference&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: dubbo:module</title><link>/zh/docs/v2.7/user/references/xml/dubbo-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-module/</guid><description>
&lt;p>模块信息配置。对应的配置类 &lt;code>org.apache.dubbo.config.ModuleConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>module&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前模块名称，用于注册中心计算模块间依赖关系&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>module.version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前模块的版本&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>模块负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>organization&lt;/td>
&lt;td>organization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:monitor</title><link>/zh/docs/v2.7/user/references/xml/dubbo-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-monitor/</guid><description>
&lt;p>监控中心配置。对应的配置类： &lt;code>org.apache.dubbo.config.MonitorConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>监控中心协议，如果为protocol=&amp;ldquo;registry&amp;rdquo;，表示从注册中心发现监控中心地址，否则直连监控中心。&lt;/td>
&lt;td>2.0.9以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>&amp;lt;url&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>N/A&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>直连监控中心服务器地址，address=&amp;ldquo;10.20.130.230:12080&amp;rdquo;&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:parameter</title><link>/zh/docs/v2.7/user/references/xml/dubbo-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-parameter/</guid><description>
&lt;p>选项参数配置。对应的配置类：&lt;code>java.util.Map&lt;/code>。同时该标签为&lt;code>&amp;lt;dubbo:protocol&amp;gt;&lt;/code>或&lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code>或&lt;code>&amp;lt;dubbo:provider&amp;gt;&lt;/code>或&lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code>或&lt;code>&amp;lt;dubbo:consumer&amp;gt;&lt;/code>的子标签，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key&lt;/td>
&lt;td>key&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>路由参数键&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>value&lt;/td>
&lt;td>value&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>路由参数值&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;napoli&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:parameter&lt;/span> key=&lt;span style="color:#2aa198">&amp;#34;http://10.20.160.198/wiki/display/dubbo/napoli.queue.name&amp;#34;&lt;/span> value=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:protocol&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;jms&amp;#34;&lt;/span> p:queue=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: dubbo:protocol</title><link>/zh/docs/v2.7/user/references/xml/dubbo-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-protocol/</guid><description>
&lt;p>服务提供者协议配置。对应的配置类： &lt;code>org.apache.dubbo.config.ProtocolConfig&lt;/code>。同时，如果需要支持多协议，可以声明多个 &lt;code>&amp;lt;dubbo:protocol&amp;gt;&lt;/code> 标签，并在 &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> 中通过 &lt;code>protocol&lt;/code> 属性指定使用的协议。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>&amp;lt;protocol&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议名称&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port&lt;/td>
&lt;td>&amp;lt;port&amp;gt;&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果&lt;b>没有&lt;/b>配置port，则自动采用默认端口，如果配置为&lt;b>-1&lt;/b>，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务端口&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>host&lt;/td>
&lt;td>&amp;lt;host&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>自动查找本机IP&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>-服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threadpool&lt;/td>
&lt;td>threadpool&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>fixed&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池类型，可选：fixed/cached&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threads&lt;/td>
&lt;td>threads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>200&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务线程池大小(固定大小)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iothreads&lt;/td>
&lt;td>threads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>cpu个数+1&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>io线程池大小(固定大小)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accepts&lt;/td>
&lt;td>accepts&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方最大可接受连接数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>payload&lt;/td>
&lt;td>payload&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8388608(=8M)&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>请求及响应数据包大小限制，单位：字节&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>codec&lt;/td>
&lt;td>codec&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议编码方式&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>serialization&lt;/td>
&lt;td>serialization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为hessian2，rmi协议缺省为java，http协议缺省为json&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accesslog&lt;/td>
&lt;td>accesslog&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>path&lt;/td>
&lt;td>&amp;lt;path&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>提供者上下文路径，为服务path的前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>transporter&lt;/td>
&lt;td>transporter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的服务端和客户端实现类型，比如：dubbo协议的mina,netty等，可以分拆为server和client配置&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server&lt;/td>
&lt;td>server&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty，http协议缺省为servlet&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>client&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的客户端实现类型，比如：dubbo协议的mina,netty等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dispatcher&lt;/td>
&lt;td>dispatcher&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为all&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all, direct, message, execution, connection等&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>queues&lt;/td>
&lt;td>queues&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池队列大小，当线程池满时，排队等待执行的队列大小，建议不要设置，当线程池满时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>charset&lt;/td>
&lt;td>charset&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>UTF-8&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>序列化编码&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>buffer&lt;/td>
&lt;td>buffer&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8192&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>网络读写缓冲区大小&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>heartbeat&lt;/td>
&lt;td>heartbeat&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开&lt;/td>
&lt;td>2.0.10以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>telnet&lt;/td>
&lt;td>telnet&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>所支持的telnet命令，多个命令用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>该协议的服务是否注册到注册中心&lt;/td>
&lt;td>2.0.8以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>contextpath&lt;/td>
&lt;td>contextpath&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为空串&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:provider</title><link>/zh/docs/v2.7/user/references/xml/dubbo-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-provider/</guid><description>
&lt;p>服务提供者缺省值配置。对应的配置类： &lt;code>org.apache.dubbo.config.ProviderConfig&lt;/code>。同时该标签为 &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> 和 &lt;code>&amp;lt;dubbo:protocol&amp;gt;&lt;/code> 标签的缺省值设置。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>协议BeanId，可以在&amp;lt;dubbo:service proivder=&amp;quot;&amp;quot;&amp;gt;中引用此ID&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>&amp;lt;protocol&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议名称&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>host&lt;/td>
&lt;td>&amp;lt;host&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>自动查找本机IP&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，建议不要配置，让Dubbo自动获取本机IP&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threads&lt;/td>
&lt;td>threads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>200&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务线程池大小(固定大小)&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>payload&lt;/td>
&lt;td>payload&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8388608(=8M)&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>请求及响应数据包大小限制，单位：字节&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>path&lt;/td>
&lt;td>&amp;lt;path&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>提供者上下文路径，为服务path的前缀&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server&lt;/td>
&lt;td>server&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty，http协议缺省为servlet&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>client&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的客户端实现类型，比如：dubbo协议的mina,netty等&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>codec&lt;/td>
&lt;td>codec&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议编码方式&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>serialization&lt;/td>
&lt;td>serialization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为hessian2，rmi协议缺省为java，http协议缺省为json&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json,xml等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>default&lt;/td>
&lt;td>&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>是否为缺省协议，用于多协议&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>service.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>exporter.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方导出服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threadpool&lt;/td>
&lt;td>threadpool&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>fixed&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池类型，可选：fixed/cached/limit(2.5.3以上)/eager(2.6.x以上)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accepts&lt;/td>
&lt;td>accepts&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供者最大可接受连接数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0.0.0&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务分组，当一个接口有多个实现，可以用分组区分&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>delay&lt;/td>
&lt;td>delay&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>延迟注册服务时间(毫秒)- ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>default.timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用超时时间(毫秒)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>default.retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>2&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>default.connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>default.loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>random&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>default.async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stub&lt;/td>
&lt;td>stub&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省代理类名，即：接口名 + Local后缀。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mock&lt;/td>
&lt;td>mock&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省Mock类名，即：接口名 + Mock后缀。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>token&lt;/td>
&lt;td>token&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>令牌验证，为空表示不开启，如果为true，表示随机生成动态令牌&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>registry&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省向所有registry注册&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>向指定注册中心注册，在多个注册中心时使用，值为&amp;lt;dubbo:registry&amp;gt;的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dynamic&lt;/td>
&lt;td>dynamic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否动态注册，如果设为false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accesslog&lt;/td>
&lt;td>accesslog&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>document&lt;/td>
&lt;td>document&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务文档URL&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>weight&lt;/td>
&lt;td>weight&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务权重&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>executes&lt;/td>
&lt;td>executes&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供者每服务每方法最大可并行执行请求数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>actives&lt;/td>
&lt;td>default.actives&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务消费者每服务每方法最大并发调用数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>生成动态代理方式，可选：jdk/javassist&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>default.cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deprecated&lt;/td>
&lt;td>deprecated&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否过时，如果设为true，消费方引用时将打印服务过时警告error日志&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>queues&lt;/td>
&lt;td>queues&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池队列大小，当线程池满时，排队等待执行的队列大小，建议不要设置，当线程池满时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>charset&lt;/td>
&lt;td>charset&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>UTF-8&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>序列化编码&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>buffer&lt;/td>
&lt;td>buffer&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8192&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>网络读写缓冲区大小&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iothreads&lt;/td>
&lt;td>iothreads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>CPU + 1&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>IO线程池，接收网络读写中断，以及序列化和反序列化，不处理业务，业务线程池参见threads配置，此线程池和CPU相关，不建议配置。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>telnet&lt;/td>
&lt;td>telnet&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>所支持的telnet命令，多个命令用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;dubbo:service&amp;gt;&lt;/td>
&lt;td>contextpath&lt;/td>
&lt;td>contextpath&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为空串&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务提供者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:reference</title><link>/zh/docs/v2.7/user/references/xml/dubbo-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-reference/</guid><description>
&lt;p>服务消费者引用服务配置。对应的配置类： &lt;code>org.apache.dubbo.config.ReferenceConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>服务引用BeanId&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>&lt;/td>
&lt;td>class&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务接口名&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务版本，与服务提供者的版本一致&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致&lt;/td>
&lt;td>1.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>timeout&lt;/td>
&lt;td>long&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的timeout&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务方法调用超时时间(毫秒)&lt;/td>
&lt;td>1.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的retries&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的connections&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的loadbalance&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的async&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>generic&lt;/td>
&lt;td>generic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的generic&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否缺省泛化接口，如果为泛化接口，将返回GenericService&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&amp;lt;dubbo:consumer&amp;gt;的check&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>启动时检查提供者是否存在，true报错，false忽略&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>url&lt;/td>
&lt;td>url&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>点对点直连服务提供者地址，将绕过注册中心&lt;/td>
&lt;td>1.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stub&lt;/td>
&lt;td>stub&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务接口客户端本地代理类名，用于在客户端执行本地逻辑，如本地缓存等，该本地代理类的构造函数必须允许传入远程代理对象，构造函数如：public XxxServiceLocal(XxxService xxxService)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mock&lt;/td>
&lt;td>mock&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务接口调用失败Mock实现类名，该Mock类必须有一个无参构造函数，与Local的区别在于，Local总是被执行，而Mock只在出现非业务异常(比如超时，网络异常等)时执行，Local在远程调用之前执行，Mock在远程调用后执行。&lt;/td>
&lt;td>Dubbo1.0.13及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cache&lt;/td>
&lt;td>cache&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>以调用参数为key，缓存返回结果，可选：lru, threadlocal, jcache等&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>validation&lt;/td>
&lt;td>validation&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否启用JSR303标准注解验证，如果启用，将对方法参数上的注解进行校验&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>选择动态代理实现策略，可选：javassist, jdk&lt;/td>
&lt;td>2.0.2以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>client&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>客户端传输类型设置，如Dubbo协议的netty或mina。&lt;/td>
&lt;td>Dubbo2.0.0以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省将从所有注册中心获服务列表后合并结果&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>从指定注册中心注册获取服务列表，在多个注册中心时使用，值为&amp;lt;dubbo:registry&amp;gt;的id属性，多个注册中心ID用逗号分隔&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>调用服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>actives&lt;/td>
&lt;td>actives&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务消费者每服务每方法最大并发调用数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>reference.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>invoker.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方引用服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务调用者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>init&lt;/td>
&lt;td>init&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否在afterPropertiesSet()时饥饿初始化引用，否则等到有人注入或引用该实例时再初始化。&lt;/td>
&lt;td>2.0.10以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>只调用指定协议的服务提供方，其它协议忽略。&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:registry</title><link>/zh/docs/v2.7/user/references/xml/dubbo-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-registry/</guid><description>
&lt;p>注册中心配置。对应的配置类： &lt;code>org.apache.dubbo.config.RegistryConfig&lt;/code>。同时如果有多个不同的注册中心，可以声明多个 &lt;code>&amp;lt;dubbo:registry&amp;gt;&lt;/code> 标签，并在 &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> 或 &lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code> 的 &lt;code>registry&lt;/code> 属性指定使用的注册中心。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>&amp;lt;host:port&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个&amp;lt;dubbo:registry&amp;gt;标签&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>&amp;lt;protocol&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心地址协议，支持&lt;code>dubbo&lt;/code>, &lt;code>multicast&lt;/code>, &lt;code>zookeeper&lt;/code>, &lt;code>redis&lt;/code>, &lt;code>consul(2.7.1)&lt;/code>, &lt;code>sofa(2.7.2)&lt;/code>, &lt;code>etcd(2.7.2)&lt;/code>, &lt;code>nacos(2.7.2)&lt;/code>等协议&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port&lt;/td>
&lt;td>&amp;lt;port&amp;gt;&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>9090&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心缺省端口，当address没有带端口时使用此端口做为缺省值&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>username&lt;/td>
&lt;td>&amp;lt;username&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>登录注册中心用户名，如果注册中心不需要验证可不填&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>password&lt;/td>
&lt;td>&amp;lt;password&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>登录注册中心密码，如果注册中心不需要验证可不填&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>transport&lt;/td>
&lt;td>registry.transporter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>网络传输方式，可选mina,netty&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>registry.timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>5000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>注册中心请求超时时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>session&lt;/td>
&lt;td>registry.session&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>60000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>注册中心会话超时时间(毫秒)，用于检测提供者非正常断线后的脏数据，比如用心跳检测的实现，此时间就是心跳间隔，不同注册中心实现不一样。&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>file&lt;/td>
&lt;td>registry.file&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>wait&lt;/td>
&lt;td>registry.wait&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>停止时等待通知完成时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>注册中心不存在时，是否报错&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否向此注册中心注册服务，如果设为false，将只订阅，不注册&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>subscribe&lt;/td>
&lt;td>subscribe&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否向此注册中心订阅服务，如果设为false，将只注册，不订阅&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dynamic&lt;/td>
&lt;td>dynamic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否动态注册，如果设为false，注册后将显示为disable状态，需人工启用，并且服务提供者停止时，也不会自动取消注册，需人工禁用。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务注册分组，跨组的服务不会相互影响，也无法相互调用，适用于环境隔离。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>simplified&lt;/td>
&lt;td>simplified&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>注册到注册中心的URL是否采用精简模式的（与低版本兼容）&lt;/td>
&lt;td>2.7.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>extra-keys&lt;/td>
&lt;td>extraKeys&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>在simplified=true时，extraKeys允许你在默认参数外将额外的key放到URL中，格式：&amp;ldquo;interface,key1,key2&amp;rdquo;。&lt;/td>
&lt;td>2.7.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: dubbo:service</title><link>/zh/docs/v2.7/user/references/xml/dubbo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/xml/dubbo-service/</guid><description>
&lt;p>服务提供者暴露服务配置。对应的配置类：&lt;code>org.apache.dubbo.config.ServiceConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>&lt;/td>
&lt;td>class&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务接口名&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ref&lt;/td>
&lt;td>&lt;/td>
&lt;td>object&lt;/td>
&lt;td>&lt;b>必填&lt;/b>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务对象实现引用&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0.0.0&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务分组，当一个接口有多个实现，可以用分组区分&lt;/td>
&lt;td>1.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>path&lt;/td>
&lt;td>&amp;lt;path&amp;gt;&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为接口名&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务路径 (注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调2.0，配置服务路径可能不兼容)&lt;/td>
&lt;td>1.0.12以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>delay&lt;/td>
&lt;td>delay&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>延迟注册服务时间(毫秒) ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务&lt;/td>
&lt;td>1.0.14以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用超时时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>2&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>100&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>random&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>local&lt;/td>
&lt;td>local&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省代理类名，即：接口名 + Local后缀，已废弃，请使用stub&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stub&lt;/td>
&lt;td>stub&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省代理类名，即：接口名 + Stub后缀，服务接口客户端本地代理类名，用于在客户端执行本地逻辑，如本地缓存等，该本地代理类的构造函数必须允许传入远程代理对象，构造函数如：public XxxServiceStub(XxxService xxxService)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mock&lt;/td>
&lt;td>mock&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省Mock类名，即：接口名 + Mock后缀，服务接口调用失败Mock实现类，该Mock类必须有一个无参构造函数，与Local的区别在于，Local总是被执行，而Mock只在出现非业务异常(比如超时，网络异常等)时执行，Local在远程调用之前执行，Mock在远程调用后执行。&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>token&lt;/td>
&lt;td>token&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>令牌验证，为空表示不开启，如果为true，表示随机生成动态令牌，否则使用静态令牌，令牌的作用是防止消费者绕过注册中心直接访问，保证注册中心的授权功能有效，如果使用点对点调用，需关闭令牌功能&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省向所有registry注册&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>向指定注册中心注册，在多个注册中心时使用，值为&amp;lt;dubbo:registry&amp;gt;的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>provider&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用第一个provider配置&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>指定provider，值为&amp;lt;dubbo:provider&amp;gt;的id属性&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deprecated&lt;/td>
&lt;td>deprecated&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否过时，如果设为true，消费方引用时将打印服务过时警告error日志&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dynamic&lt;/td>
&lt;td>dynamic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否动态注册，如果设为false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accesslog&lt;/td>
&lt;td>accesslog&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>document&lt;/td>
&lt;td>document&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务文档URL&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>weight&lt;/td>
&lt;td>weight&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务权重&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>executes&lt;/td>
&lt;td>executes&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供者每服务每方法最大可并行执行请求数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>生成动态代理方式，可选：jdk/javassist&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>service.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>exporter.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方导出服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>使用指定的协议暴露服务，在多协议时使用，值为&amp;lt;dubbo:protocol&amp;gt;的id属性，多个协议ID用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务提供者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>该协议的服务是否注册到注册中心&lt;/td>
&lt;td>2.0.8以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Nacos 注册中心</title><link>/zh/docs/v2.7/user/references/registry/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/registry/nacos/</guid><description>
&lt;p>Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 &lt;a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos">&lt;code>dubbo-registry-nacos&lt;/code>&lt;/a> 则是 Dubbo 融合 Nacos 注册中心的实现。&lt;/p>
&lt;h2 id="预备工作">预备工作&lt;/h2>
&lt;p>当您将 &lt;a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos">dubbo-registry-nacos&lt;/a> 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 &lt;a href="https://nacos.io/en-us/docs/quick-start.html">Nacos 快速入门&lt;/a>。建议使用 Nacos &lt;code>1.0.0&lt;/code> 及以上的版本。&lt;/p>
&lt;h2 id="快速上手">快速上手&lt;/h2>
&lt;p>Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。&lt;/p>
&lt;h3 id="增加-maven-依赖">增加 Maven 依赖&lt;/h3>
&lt;p>首先，您需要将 &lt;code>dubbo-registry-nacos&lt;/code> 的 Maven 依赖添加到您的项目 &lt;code>pom.xml&lt;/code> 文件中，并且强烈地推荐您使用 Dubbo &lt;code>2.6.5&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dependencies&amp;gt;&lt;/span>
...
&lt;span style="color:#586e75">&amp;lt;!-- Dubbo Nacos registry dependency --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>dubbo-registry-nacos&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>0.0.2&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- Keep latest Nacos client version --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba.nacos&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>nacos-client&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>[0.6.1,)&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- Dubbo dependency --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>dubbo&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>2.6.5&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- Alibaba Spring Context extension --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba.spring&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context-support&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>1.0.2&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
...
&lt;span style="color:#268bd2">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当项目中添加 &lt;code>dubbo-registry-nacos&lt;/code> 后，您无需显式地编程实现服务发现和注册逻辑，实际实现由该三方包提供，接下来配置 Naocs 注册中心。&lt;/p>
&lt;h3 id="配置注册中心">配置注册中心&lt;/h3>
&lt;p>假设您 Dubbo 应用使用 Spring Framework 装配，将有两种配置方法可选，分别为：&lt;a href="https://mercyblitz.github.io/2018/01/18/Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/">Dubbo Spring 外部化配置&lt;/a>以及 Spring XML 配置文件，推荐前者。&lt;/p>
&lt;h3 id="dubbo-spring-外部化配置">Dubbo Spring 外部化配置&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://mercyblitz.github.io/2018/01/18/Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/">参考&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Dubbo Spring 外部化配置是由 Dubbo &lt;code>2.5.8&lt;/code> 引入的新特性，可通过 Spring &lt;code>Environment&lt;/code> 属性自动地生成并绑定 Dubbo 配置 Bean，实现配置简化，并且降低微服务开发门槛。&lt;/p>
&lt;p>假设您的 Nacos Server 同样运行在服务器 &lt;code>10.20.153.10&lt;/code> 上，并使用默认 Nacos 服务端口 &lt;code>8848&lt;/code>，您只需将 &lt;code>dubbo.registry.address&lt;/code> 属性调整如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">## 其他属性保持不变
## Nacos registry address
dubbo.registry.address = nacos://10.20.153.10:8848
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>随后，重启您的 Dubbo 应用，Dubbo 的服务提供和消费信息在 Nacos 控制台中可以显示：&lt;/p>
&lt;p>&lt;img src="/imgs/blog/dubbo-registry-nacos-1.png" alt="dubbo-registry-nacos-1.png">&lt;/p>
&lt;p>如图所示，服务名前缀为 &lt;code>providers:&lt;/code> 的信息为服务提供者的元信息，&lt;code>consumers:&lt;/code> 则代表服务消费者的元信息。点击“&lt;strong>详情&lt;/strong>”可查看服务状态详情：&lt;/p>
&lt;p>&lt;img src="/imgs/blog/dubbo-registry-nacos-2.png" alt="image-dubbo-registry-nacos-2.png">&lt;/p>
&lt;p>如果您正在使用 Spring XML 配置文件装配 Dubbo 注册中心的话，请参考下一节。&lt;/p>
&lt;h3 id="spring-xml-配置文件">Spring XML 配置文件&lt;/h3>
&lt;p>与 &lt;a href="https://mercyblitz.github.io/2018/01/18/Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/">Dubbo Spring 外部化配置&lt;/a> 配置类似，只需要调整 &lt;code>address&lt;/code> 属性配置即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#719e07">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:application&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo-provider-xml-demo&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 使用 Nacos 注册中心 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;nacos://10.20.153.10:8848&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
...
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启 Dubbo 应用后，您同样也能发现服务提供方和消费方的注册元信息呈现在 Nacos 控制台中：&lt;/p>
&lt;p>&lt;img src="/imgs/blog/dubbo-registry-nacos-3.png" alt="dubbo-registry-nacos-3.png">&lt;/p></description></item><item><title>Docs: XML 配置</title><link>/zh/docs/v2.7/user/configuration/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/configuration/xml/</guid><description>
&lt;p>有关 XML 的详细配置项，请参见：&lt;a href="../../references/xml">配置参考手册&lt;/a>。如果不想使用 Spring 配置，而希望通过 API 的方式进行调用，请参见：&lt;a href="../api">API配置&lt;/a>。想知道如何使用配置，请参见：&lt;a href="../../quick-start">快速启动&lt;/a>。&lt;/p>
&lt;p>请在此查看文档描述的&lt;a href="https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-basic">完整示例&lt;/a>&lt;/p>
&lt;h2 id="providerxml-示例">provider.xml 示例&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span>&lt;span style="color:#2aa198"> http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:application&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;demo-provider&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;20890&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span> class=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34;&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="consumerxml示例">consumer.xml示例&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span>&lt;span style="color:#2aa198"> http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:application&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;demo-consumer&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> group=&lt;span style="color:#2aa198">&amp;#34;aaa&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span> check=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;jms&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:parameter&lt;/span> key=&lt;span style="color:#2aa198">&amp;#34;queue&amp;#34;&lt;/span> value=&lt;span style="color:#2aa198">&amp;#34;your_queue&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:protocol&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或： &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xmlns:p=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/p&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;jms&amp;#34;&lt;/span> p:queue=&lt;span style="color:#2aa198">&amp;#34;your_queue&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置之间的关系">配置之间的关系&lt;/h2>
&lt;p>&lt;img src="/imgs/user/dubbo-config.jpg" alt="dubbo-config">&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标签&lt;/th>
&lt;th>用途&lt;/th>
&lt;th>解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:service/&amp;gt;&lt;/code>&lt;/td>
&lt;td>服务配置&lt;/td>
&lt;td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:reference/&amp;gt;&lt;/code> &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/td>
&lt;td>引用配置&lt;/td>
&lt;td>用于创建一个远程服务代理，一个引用可以指向多个注册中心&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:protocol/&amp;gt;&lt;/code>&lt;/td>
&lt;td>协议配置&lt;/td>
&lt;td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:application/&amp;gt;&lt;/code>&lt;/td>
&lt;td>应用配置&lt;/td>
&lt;td>用于配置当前应用信息，不管该应用是提供者还是消费者&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:module/&amp;gt;&lt;/code>&lt;/td>
&lt;td>模块配置&lt;/td>
&lt;td>用于配置当前模块信息，可选&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:registry/&amp;gt;&lt;/code>&lt;/td>
&lt;td>注册中心配置&lt;/td>
&lt;td>用于配置连接注册中心相关信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:monitor/&amp;gt;&lt;/code>&lt;/td>
&lt;td>监控中心配置&lt;/td>
&lt;td>用于配置连接监控中心相关信息，可选&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:provider/&amp;gt;&lt;/code>&lt;/td>
&lt;td>提供方配置&lt;/td>
&lt;td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:consumer/&amp;gt;&lt;/code>&lt;/td>
&lt;td>消费方配置&lt;/td>
&lt;td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:method/&amp;gt;&lt;/code>&lt;/td>
&lt;td>方法配置&lt;/td>
&lt;td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;dubbo:argument/&amp;gt;&lt;/code>&lt;/td>
&lt;td>参数配置&lt;/td>
&lt;td>用于指定方法参数配置&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="不同粒度配置的覆盖关系">不同粒度配置的覆盖关系&lt;/h2>
&lt;p>以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：&lt;/p>
&lt;ul>
&lt;li>方法级优先，接口级次之，全局配置再次之。&lt;/li>
&lt;li>如果级别一样，则消费方优先，提供方次之。&lt;/li>
&lt;/ul>
&lt;p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。&lt;/p>
&lt;p>&lt;img src="/imgs/user/dubbo-config-override.jpg" alt="dubbo-config-override">&lt;/p>
&lt;p>（建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置）。&lt;/p>
&lt;p>理论上 ReferenceConfig 中除了&lt;code>interface&lt;/code>这一项，其他所有配置项都可以缺省不配置，框架会自动使用ConsumerConfig，ServiceConfig, ProviderConfig等提供的缺省配置。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;code>2.1.0&lt;/code> 开始支持，注意声明：&lt;code>xmlns:p=&amp;quot;http://www.springframework.org/schema/p&amp;quot;&lt;/code> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>引用缺省是延迟初始化的，只有引用被注入到其它 Bean，或被 &lt;code>getBean()&lt;/code> 获取，才会初始化。如果需要饥饿加载，即没有人引用也立即生成动态代理，可以配置：&lt;code>&amp;lt;dubbo:reference ... init=&amp;quot;true&amp;quot; /&amp;gt;&lt;/code> &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: Zookeeper 注册中心</title><link>/zh/docs/v2.7/user/references/registry/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/registry/zookeeper/</guid><description>
&lt;p>&lt;a href="http://zookeeper.apache.org">Zookeeper&lt;/a> 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>&lt;img src="/imgs/user/zookeeper.jpg" alt="/user-guide/images/zookeeper.jpg">&lt;/p>
&lt;p>流程说明：&lt;/p>
&lt;ul>
&lt;li>服务提供者启动时: 向 &lt;code>/dubbo/com.foo.BarService/providers&lt;/code> 目录下写入自己的 URL 地址&lt;/li>
&lt;li>服务消费者启动时: 订阅 &lt;code>/dubbo/com.foo.BarService/providers&lt;/code> 目录下的提供者 URL 地址。并向 &lt;code>/dubbo/com.foo.BarService/consumers&lt;/code> 目录下写入自己的 URL 地址&lt;/li>
&lt;li>监控中心启动时: 订阅 &lt;code>/dubbo/com.foo.BarService&lt;/code> 目录下的所有提供者和消费者 URL 地址。&lt;/li>
&lt;/ul>
&lt;p>支持以下功能：&lt;/p>
&lt;ul>
&lt;li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息&lt;/li>
&lt;li>当注册中心重启时，能自动恢复注册数据，以及订阅请求&lt;/li>
&lt;li>当会话过期时，能自动恢复注册数据，以及订阅请求&lt;/li>
&lt;li>当设置 &lt;code>&amp;lt;dubbo:registry check=&amp;quot;false&amp;quot; /&amp;gt;&lt;/code> 时，记录失败注册和订阅请求，后台定时重试&lt;/li>
&lt;li>可通过 &lt;code>&amp;lt;dubbo:registry username=&amp;quot;admin&amp;quot; password=&amp;quot;1234&amp;quot; /&amp;gt;&lt;/code> 设置 zookeeper 登录信息&lt;/li>
&lt;li>可通过 &lt;code>&amp;lt;dubbo:registry group=&amp;quot;dubbo&amp;quot; /&amp;gt;&lt;/code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。&lt;/li>
&lt;li>支持 &lt;code>*&lt;/code> 号通配符 &lt;code>&amp;lt;dubbo:reference group=&amp;quot;*&amp;quot; version=&amp;quot;*&amp;quot; /&amp;gt;&lt;/code>，可订阅服务的所有分组和所有版本的提供者&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.zookeeper&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>zookeeper&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>3.3.3&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或直接&lt;a href="http://repo1.maven.org/maven2/org/apache/zookeeper/zookeeper">下载&lt;/a>。&lt;/p>
&lt;p>Dubbo 支持 zkclient 和 curator 两种 Zookeeper 客户端实现：&lt;/p>
&lt;p>&lt;strong>注意:在2.7.x的版本中已经移除了zkclient的实现,如果要使用zkclient客户端,需要自行拓展&lt;/strong>&lt;/p>
&lt;h3 id="使用-zkclient-客户端">使用 zkclient 客户端&lt;/h3>
&lt;p>从 &lt;code>2.2.0&lt;/code> 版本开始缺省为 zkclient 实现，以提升 zookeeper 客户端的健壮性。&lt;a href="https://github.com/sgroschupf/zkclient">zkclient&lt;/a> 是 Datameer 开源的一个 Zookeeper 客户端实现。&lt;/p>
&lt;p>缺省配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> ... client=&lt;span style="color:#2aa198">&amp;#34;zkclient&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">dubbo.registry.client&lt;span style="color:#719e07">=&lt;/span>zkclient
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">zookeeper://10.20.153.10:2181?client&lt;span style="color:#719e07">=&lt;/span>zkclient
&lt;/code>&lt;/pre>&lt;/div>&lt;p>需依赖或直接&lt;a href="http://repo1.maven.org/maven2/com/github/sgroschupf/zkclient">下载&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.github.sgroschupf&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>zkclient&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>0.1&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-curator-客户端">使用 curator 客户端&lt;/h3>
&lt;p>从 &lt;code>2.3.0&lt;/code> 版本开始支持可选 curator 实现。&lt;a href="https://github.com/Netflix/curator">Curator&lt;/a> 是 Netflix 开源的一个 Zookeeper 客户端实现。&lt;/p>
&lt;p>如果需要改为 curator 实现，请配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> ... client=&lt;span style="color:#2aa198">&amp;#34;curator&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">dubbo.registry.client&lt;span style="color:#719e07">=&lt;/span>curator
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">zookeeper://10.20.153.10:2181?client&lt;span style="color:#719e07">=&lt;/span>curator
&lt;/code>&lt;/pre>&lt;/div>&lt;p>需依赖或直接&lt;a href="http://repo1.maven.org/maven2/com/netflix/curator/curator-framework">下载&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.netflix.curator&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>curator-framework&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>1.1.10&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zookeeper 单机配置:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;zookeeper&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:2181&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zookeeper 集群配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;zookeeper&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同一 Zookeeper，分成多组注册中心:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;chinaRegistry&amp;#34;&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;zookeeper&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:2181&amp;#34;&lt;/span> group=&lt;span style="color:#2aa198">&amp;#34;china&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;intlRegistry&amp;#34;&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;zookeeper&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:2181&amp;#34;&lt;/span> group=&lt;span style="color:#2aa198">&amp;#34;intl&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="zookeeper-安装">zookeeper 安装&lt;/h2>
&lt;p>安装方式参见: &lt;a href="../../../../admin/install/zookeeper">Zookeeper安装手册&lt;/a>，只需搭一个原生的 Zookeeper 服务器，并将 &lt;a href="../../../quick-start">Quick Start&lt;/a> 中 Provider 和 Consumer 里的 &lt;code>conf/dubbo.properties&lt;/code> 中的 &lt;code>dubbo.registry.address&lt;/code> 的值改为 &lt;code>zookeeper://127.0.0.1:2181&lt;/code> 即可使用。&lt;/p>
&lt;h2 id="可靠性声明">可靠性声明&lt;/h2>
&lt;p>阿里内部并没有采用 Zookeeper 做为注册中心，而是使用自己实现的基于数据库的注册中心，即：Zookeeper 注册中心并没有在阿里内部长时间运行的可靠性保障，此 Zookeeper 桥接实现只为开源版本提供，其可靠性依赖于 Zookeeper 本身的可靠性。&lt;/p>
&lt;h2 id="兼容性声明">兼容性声明&lt;/h2>
&lt;p>因 &lt;code>2.0.8&lt;/code> 最初设计的 zookeeper 存储结构不能扩充不同类型的数据，&lt;code>2.0.9&lt;/code> 版本做了调整，所以不兼容，需全部改用 &lt;code>2.0.9&lt;/code> 版本才行，以后的版本会保持兼容 &lt;code>2.0.9&lt;/code>。&lt;code>2.2.0&lt;/code> 版本改为基于 zkclient 实现，需增加 zkclient 的依赖包，&lt;code>2.3.0&lt;/code> 版本增加了基于 curator 的实现，作为可选实现策略。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>建议使用 &lt;code>2.3.3&lt;/code> 以上版本的 zookeeper 注册中心客户端 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: 协议扩展</title><link>/zh/docs/v2.7/dev/impls/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/impls/protocol/</guid><description>
&lt;h2 id="扩展说明">扩展说明&lt;/h2>
&lt;p>RPC 协议扩展，封装远程调用细节。&lt;/p>
&lt;p>契约：&lt;/p>
&lt;ul>
&lt;li>当用户调用 &lt;code>refer()&lt;/code> 所返回的 &lt;code>Invoker&lt;/code> 对象的 &lt;code>invoke()&lt;/code> 方法时，协议需相应执行同 URL 远端 &lt;code>export()&lt;/code> 传入的 &lt;code>Invoker&lt;/code> 对象的 &lt;code>invoke()&lt;/code> 方法。&lt;/li>
&lt;li>其中，&lt;code>refer()&lt;/code> 返回的 &lt;code>Invoker&lt;/code> 由协议实现，协议通常需要在此 &lt;code>Invoker&lt;/code> 中发送远程请求，&lt;code>export()&lt;/code> 传入的 &lt;code>Invoker&lt;/code> 由框架实现并传入，协议不需要关心。&lt;/li>
&lt;/ul>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>协议不关心业务接口的透明代理，以 &lt;code>Invoker&lt;/code> 为中心，由外层将 &lt;code>Invoker&lt;/code> 转换为业务接口。&lt;/li>
&lt;li>协议不一定要是 TCP 网络通讯，比如通过共享文件，IPC 进程间通讯等。&lt;/li>
&lt;/ul>
&lt;h2 id="扩展接口">扩展接口&lt;/h2>
&lt;ul>
&lt;li>&lt;code>org.apache.dubbo.rpc.Protocol&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.Exporter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.Invoker&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Protocol&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">/**
&lt;/span>&lt;span style="color:#586e75"> * 暴露远程服务：&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;span style="color:#586e75"> * @param &amp;lt;T&amp;gt; 服务的类型
&lt;/span>&lt;span style="color:#586e75"> * @param invoker 服务的执行体
&lt;/span>&lt;span style="color:#586e75"> * @return exporter 暴露服务的引用，用于取消暴露
&lt;/span>&lt;span style="color:#586e75"> * @throws RpcException 当暴露服务出错时抛出，比如端口已占用
&lt;/span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">/**
&lt;/span>&lt;span style="color:#586e75"> * 引用远程服务：&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> * 3. 当url中有设置check=false时，连接失败不能抛出异常，需内部自动恢复。&amp;lt;br&amp;gt;
&lt;/span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;span style="color:#586e75"> * @param &amp;lt;T&amp;gt; 服务的类型
&lt;/span>&lt;span style="color:#586e75"> * @param type 服务的类型
&lt;/span>&lt;span style="color:#586e75"> * @param url 远程服务的URL地址
&lt;/span>&lt;span style="color:#586e75"> * @return invoker 服务的本地代理
&lt;/span>&lt;span style="color:#586e75"> * @throws RpcException 当连接服务提供方失败时抛出
&lt;/span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">refer&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type&lt;span style="color:#719e07">,&lt;/span> URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展配置">扩展配置&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#586e75">&amp;lt;!-- 声明协议，如果没有配置id，将以name为id --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;xxx1&amp;#34;&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 引用协议，如果没有配置protocol属性，将在ApplicationContext中自动扫描protocol配置 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;xxx1&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 引用协议缺省值，当&amp;lt;dubbo:service&amp;gt;没有配置prototol属性时，使用此配置 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:provider&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;xxx1&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="已知扩展">已知扩展&lt;/h2>
&lt;ul>
&lt;li>&lt;code>org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.protocol.rmi.RmiProtocol&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.protocol.http.HttpProtocol&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.protocol.http.hessian.HessianProtocol&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="扩展示例">扩展示例&lt;/h2>
&lt;p>Maven项目结构：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">src
|-main
|-java
|-com
|-xxx
|-XxxProtocol.java (实现Protocol接口)
|-XxxExporter.java (实现Exporter接口)
|-XxxInvoker.java (实现Invoker接口)
|-resources
|-META-INF
|-dubbo
|-org.apache.dubbo.rpc.Protocol (纯文本文件，内容为：xxx=com.xxx.XxxProtocol)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>XxxProtocol.java：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> com.xxx&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Protocol&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxProtocol&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Protocol &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> XxxExporter&lt;span style="color:#719e07">(&lt;/span>invoker&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">refer&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type&lt;span style="color:#719e07">,&lt;/span> URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> XxxInvoker&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>XxxExporter.java：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> com.xxx&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.support.AbstractExporter&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxExporter&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> AbstractExporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">XxxExporter&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RemotingException&lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">super&lt;/span>&lt;span style="color:#719e07">(&lt;/span>invoker&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">unexport&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">super&lt;/span>&lt;span style="color:#719e07">.&lt;/span>unexport&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>XxxInvoker.java：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> com.xxx&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.support.AbstractInvoker&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxInvoker&lt;/span>&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> AbstractInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">XxxInvoker&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type&lt;span style="color:#719e07">,&lt;/span> URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RemotingException&lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">super&lt;/span>&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#268bd2">abstract&lt;/span> Object &lt;span style="color:#268bd2">doInvoke&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invocation invocation&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> Throwable &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>META-INF/dubbo/org.apache.dubbo.rpc.Protocol：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">xxx=com.xxx.XxxProtocol
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 启动时检查</title><link>/zh/docs/v2.7/user/examples/preflight-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/examples/preflight-check/</guid><description>
&lt;p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 &lt;code>check=&amp;quot;true&amp;quot;&lt;/code>。&lt;/p>
&lt;p>可以通过 &lt;code>check=&amp;quot;false&amp;quot;&lt;/code> 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。&lt;/p>
&lt;p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 &lt;code>check=&amp;quot;false&amp;quot;&lt;/code>，总是会返回引用，当服务恢复时，能自动连上。&lt;/p>
&lt;h2 id="示例">示例&lt;/h2>
&lt;h3 id="通过-spring-配置文件">通过 spring 配置文件&lt;/h3>
&lt;p>关闭某个服务的启动时检查 (没有提供者时报错)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> check=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>关闭所有服务的启动时检查 (没有提供者时报错)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:consumer&lt;/span> check=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>关闭注册中心启动时检查 (注册订阅失败时报错)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> check=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过-dubboproperties">通过 dubbo.properties&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过--d-参数">通过 -D 参数&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">java -Ddubbo.reference.com.foo.BarService.check&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
java -Ddubbo.reference.check&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
java -Ddubbo.consumer.check&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
java -Ddubbo.registry.check&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置的含义">配置的含义&lt;/h2>
&lt;p>&lt;code>dubbo.reference.check=false&lt;/code>，强制改变所有 reference 的 check 值，就算配置中有声明，也会被覆盖。&lt;/p>
&lt;p>&lt;code>dubbo.consumer.check=false&lt;/code>，是设置 check 的缺省值，如果配置中有显式的声明，如：&lt;code>&amp;lt;dubbo:reference check=&amp;quot;true&amp;quot;/&amp;gt;&lt;/code>，不会受影响。&lt;/p>
&lt;p>&lt;code>dubbo.registry.check=false&lt;/code>，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。&lt;/p></description></item><item><title>Docs: 快速开始</title><link>/zh/docs/v2.7/user/languages/erlang/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/languages/erlang/quick-start/</guid><description>
&lt;p>建议先使用 java 定义接口 jar，并使用 &lt;a href="https://github.com/apache/dubbo-erlang/tree/master/tools/erlanalysis">erlanalysis&lt;/a> 工具解析java接口至Erlang lib&lt;/p>
&lt;h2 id="导入依赖库">导入依赖库&lt;/h2>
&lt;h3 id="使用-rebar-编译工具">使用 Rebar 编译工具。&lt;/h3>
&lt;p>Add dubblerl to rebar.config with your project&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">{deps, [
{dubboerl, {git, &lt;span style="color:#2aa198">&amp;#34;https://github.com/apache/dubbo-erlang.git&amp;#34;&lt;/span>, {branch, &lt;span style="color:#2aa198">&amp;#34;master&amp;#34;&lt;/span>}}}
]}.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-erlangmk-编译工具">使用 erlang.mk 编译工具&lt;/h3>
&lt;p>&lt;code>待补充&lt;/code>&lt;/p>
&lt;h2 id="导入接口库">导入接口库&lt;/h2>
&lt;p>Suppose the interface lib you exported is called dubbo_service.&lt;/p>
&lt;ul>
&lt;li>If you didn&amp;rsquo;t upload your lib to your git repository, It is recommended that you copy the &lt;code>dubbo_service&lt;/code> lib
into the project&amp;rsquo;s &lt;code>apps&lt;/code> directory.&lt;/li>
&lt;li>If it is upload to your git repository, you can import like this:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">{deps, [
{dubboerl, {git, &lt;span style="color:#2aa198">&amp;#34;https://github.com/apache/dubbo-erlang.git&amp;#34;&lt;/span>, {branch, &lt;span style="color:#2aa198">&amp;#34;master&amp;#34;&lt;/span>}}},
{dubbo_service,{git,&lt;span style="color:#2aa198">&amp;#34;${INTERFACE_LIB_URL}&amp;#34;&lt;/span>,{branch,&lt;span style="color:#2aa198">&amp;#34;master&amp;#34;&lt;/span>}}} &lt;span style="color:#586e75">%% replace ${INTERFACE_LIB_URL} with your lib git repos url
&lt;/span>&lt;span style="color:#586e75">&lt;/span>]}.
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="消费者配置">消费者配置&lt;/h2>
&lt;p>Please reference &lt;a href="./reference.md">Reference Config&lt;/a>&lt;/p>
&lt;h2 id="init-dubbolib-in-your-project">Init dubbolib in your project&lt;/h2>
&lt;p>It is need you&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">dubboerl:&lt;span style="color:#268bd2">init&lt;/span>().
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何调用">如何调用？&lt;/h2>
&lt;h3 id="同步调用">同步调用&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">&lt;span style="color:#268bd2">Request&lt;/span> &lt;span style="color:#719e07">=&lt;/span> #userInfoRequest{requestId &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">123&lt;/span>, username &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;testname&amp;#34;&lt;/span>},
{ok,&lt;span style="color:#268bd2">RequestRef&lt;/span>,&lt;span style="color:#268bd2">Response&lt;/span>,&lt;span style="color:#268bd2">RpcContent&lt;/span>} &lt;span style="color:#719e07">=&lt;/span> userOperator:&lt;span style="color:#268bd2">queryUserInfo&lt;/span>(&lt;span style="color:#268bd2">Request&lt;/span>,#{sync&lt;span style="color:#719e07">=&amp;gt;&lt;/span> true}).
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If it occur error, is reponse &lt;code>{error,Reason}&lt;/code>.&lt;/p>
&lt;h3 id="异步调用">异步调用&lt;/h3>
&lt;p>Default is Async call.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">&lt;span style="color:#268bd2">Request&lt;/span> &lt;span style="color:#719e07">=&lt;/span> #userInfoRequest{requestId &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">123&lt;/span>, username &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;testname&amp;#34;&lt;/span>},
{ok,&lt;span style="color:#268bd2">RequestRef&lt;/span>} &lt;span style="color:#719e07">=&lt;/span> userOperator:&lt;span style="color:#268bd2">queryUserInfo&lt;/span>(&lt;span style="color:#268bd2">Request&lt;/span>).
&lt;span style="color:#586e75">%% you can receive the message after.
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#268bd2">handle_cast&lt;/span>({msg_back,&lt;span style="color:#268bd2">RequestRef&lt;/span>,&lt;span style="color:#268bd2">Response&lt;/span>,&lt;span style="color:#268bd2">RpcContent&lt;/span>},&lt;span style="color:#268bd2">State&lt;/span>).
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="示例">示例&lt;/h2>
&lt;p>参考项目 &lt;a href="https://github.com/apache/dubbo-erlang/tree/master/samples">dubboerl_demo&lt;/a>&lt;/p></description></item><item><title>Docs: 如何成为 Dubbo Committer</title><link>/zh/docs/contribution-guidelines/contributor/become-a-committer_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/contribution-guidelines/contributor/become-a-committer_dev/</guid><description>
&lt;p>每个人都可以成为 Apache 项目的贡献者。作为一个贡献者只是意味着你对项目感兴趣并以某种方式做出贡献，从提出合理的问题（这些问题记录了项目并向开发人员提供反馈）到提供新的特性作为补丁。&lt;/p>
&lt;p>如果你成为对一个项目有价值的贡献者，你有可能被邀请成为一个 committer。committer 是 ASF（Apache软件基金会）中用来表示提交特定项目的人的术语。它给你带来对项目仓库和资源写的权限。&lt;/p>
&lt;p>在 Dubbo 社区，如果一个 committer 获得大量的优秀成绩，就可以被邀请加入项目管理委员会（PMC）。&lt;/p>
&lt;p>当您不熟悉ASF使用的开源的开发过程时，有时难以理解的一点，就是我们更重视社区而不是代码。一个强大而健康的社区将受到尊重，成为一个有趣和有益的地方。更重要的是，一个多元化和健康的社区可以长时间的持续支持代码，即使个别公司在这个领域来来往往，也是如此。&lt;/p>
&lt;p>更多详细信息可以在&lt;a href="https://community.apache.org/contributors/">这里&lt;/a>找到。&lt;/p>
&lt;h3 id="我可以贡献什么">我可以贡献什么？&lt;/h3>
&lt;p>请参阅&lt;a href="new-contributor-guide_dev.md">新的贡献者指南&lt;/a>。&lt;/p></description></item><item><title>Docs: 服务路由</title><link>/zh/docs/v2.7/dev/source/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/source/router/</guid><description>
&lt;h2 id="1-简介">1. 简介&lt;/h2>
&lt;p>上一篇文章分析了集群容错的第一部分 — 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。在详细分析服务路由的源码之前，先来介绍一下服务路由是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter。其中条件路由是我们最常使用的，标签路由是一个新的实现，暂时还未发布，该实现预计会在 2.7.x 版本中发布。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。&lt;/p>
&lt;h2 id="2-源码分析">2. 源码分析&lt;/h2>
&lt;p>条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：&lt;/p>
&lt;p>&lt;code>host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&lt;/code>&lt;/p>
&lt;p>该条规则表示 IP 为 10.20.153.10 的服务消费者&lt;strong>只可&lt;/strong>调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：&lt;/p>
&lt;p>&lt;code>[服务消费者匹配条件] =&amp;gt; [服务提供者匹配条件]&lt;/code>&lt;/p>
&lt;p>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。官方文档中对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。&lt;/p>
&lt;p>条件路由实现类 ConditionRouter 在进行工作前，需要先对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。下面，我们先从表达式解析过程看起。&lt;/p>
&lt;h3 id="21-表达式解析">2.1 表达式解析&lt;/h3>
&lt;p>条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ConditionRouter&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>url &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 获取 priority 和 force 配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>priority &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>PRIORITY_KEY&lt;span style="color:#719e07">,&lt;/span> 0&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>force &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>FORCE_KEY&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取路由规则
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String rule &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameterAndDecoded&lt;span style="color:#719e07">(&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>RULE_KEY&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>rule &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>trim&lt;span style="color:#719e07">().&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Illegal route rule!&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
rule &lt;span style="color:#719e07">=&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>replace&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;consumer.&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>replace&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;provider.&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 定位 =&amp;gt; 分隔符
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>indexOf&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;=&amp;gt;&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 分别获取服务消费者和提供者匹配规则
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String whenRule &lt;span style="color:#719e07">=&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> 0 &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">:&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">).&lt;/span>trim&lt;span style="color:#719e07">();&lt;/span>
String thenRule &lt;span style="color:#719e07">=&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> 0 &lt;span style="color:#719e07">?&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>trim&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">:&lt;/span> rule&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">+&lt;/span> 2&lt;span style="color:#719e07">).&lt;/span>trim&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 解析服务消费者匹配规则
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> when &lt;span style="color:#719e07">=&lt;/span>
StringUtils&lt;span style="color:#719e07">.&lt;/span>isBlank&lt;span style="color:#719e07">(&lt;/span>whenRule&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>whenRule&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;()&lt;/span> &lt;span style="color:#719e07">:&lt;/span> parseRule&lt;span style="color:#719e07">(&lt;/span>whenRule&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 解析服务提供者匹配规则
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> then &lt;span style="color:#719e07">=&lt;/span>
StringUtils&lt;span style="color:#719e07">.&lt;/span>isBlank&lt;span style="color:#719e07">(&lt;/span>thenRule&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>thenRule&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">:&lt;/span> parseRule&lt;span style="color:#719e07">(&lt;/span>thenRule&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 将解析出的匹配规则分别赋值给 whenCondition 和 thenCondition 成员变量
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>whenCondition &lt;span style="color:#719e07">=&lt;/span> when&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>thenCondition &lt;span style="color:#719e07">=&lt;/span> then&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>ParseException e&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>e&lt;span style="color:#719e07">.&lt;/span>getMessage&lt;span style="color:#719e07">(),&lt;/span> e&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，ConditionRouter 构造方法先是对路由规则做预处理，然后调用 parseRule 方法分别对服务提供者和消费者规则进行解析，最后将解析结果赋值给 whenCondition 和 thenCondition 成员变量。ConditionRouter 构造方法不是很复杂，这里就不多说了。下面我们把重点放在 parseRule 方法上，在详细介绍这个方法之前，我们先来看一个内部类。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">MatchPair&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">final&lt;/span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> matches &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashSet&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;();&lt;/span>
&lt;span style="color:#268bd2">final&lt;/span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> mismatches &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashSet&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>MatchPair 内部包含了两个 Set 类型的成员变量，分别用于存放匹配和不匹配的条件。这个类两个成员变量会在 parseRule 方法中被用到，下面来看一下。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">parseRule&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String rule&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">throws&lt;/span> ParseException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 定义条件映射集合
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> condition &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>StringUtils&lt;span style="color:#719e07">.&lt;/span>isBlank&lt;span style="color:#719e07">(&lt;/span>rule&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> condition&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
MatchPair pair &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> values &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 通过正则表达式匹配路由规则，ROUTE_PATTERN = ([&amp;amp;!=,]*)\s*([^&amp;amp;!=,\s]+)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 这个表达式看起来不是很好理解，第一个括号内的表达式用于匹配&amp;#34;&amp;amp;&amp;#34;, &amp;#34;!&amp;#34;, &amp;#34;=&amp;#34; 和 &amp;#34;,&amp;#34; 等符号。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 第二括号内的用于匹配英文字母，数字等字符。举个例子说明一下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// host = 2.2.2.2 &amp;amp; host != 1.1.1.1 &amp;amp; method = hello
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 匹配结果如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 括号一 括号二
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 1. null host
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 2. = 2.2.2.2
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 3. &amp;amp; host
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 4. != 1.1.1.1
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 5. &amp;amp; method
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 6. = hello
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> Matcher matcher &lt;span style="color:#719e07">=&lt;/span> ROUTE_PATTERN&lt;span style="color:#719e07">.&lt;/span>matcher&lt;span style="color:#719e07">(&lt;/span>rule&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">while&lt;/span> &lt;span style="color:#719e07">(&lt;/span>matcher&lt;span style="color:#719e07">.&lt;/span>find&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取括号一内的匹配结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String separator &lt;span style="color:#719e07">=&lt;/span> matcher&lt;span style="color:#719e07">.&lt;/span>group&lt;span style="color:#719e07">(&lt;/span>1&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 获取括号二内的匹配结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String content &lt;span style="color:#719e07">=&lt;/span> matcher&lt;span style="color:#719e07">.&lt;/span>group&lt;span style="color:#719e07">(&lt;/span>2&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 分隔符为空，表示匹配的是表达式的开始部分
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>separator &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> separator&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 创建 MatchPair 对象
&lt;/span>&lt;span style="color:#586e75">&lt;/span> pair &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MatchPair&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 存储 &amp;lt;匹配项, MatchPair&amp;gt; 键值对，比如 &amp;lt;host, MatchPair&amp;gt;
&lt;/span>&lt;span style="color:#586e75">&lt;/span> condition&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">,&lt;/span> pair&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 如果分隔符为 &amp;amp;，表明接下来也是一个条件
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;&amp;amp;&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>separator&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 尝试从 condition 获取 MatchPair
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>condition&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 未获取到 MatchPair，重新创建一个，并放入 condition 中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> pair &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MatchPair&lt;span style="color:#719e07">();&lt;/span>
condition&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">,&lt;/span> pair&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
pair &lt;span style="color:#719e07">=&lt;/span> condition&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 分隔符为 =
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;=&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>separator&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>pair &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ParseException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Illegal route rule ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
values &lt;span style="color:#719e07">=&lt;/span> pair&lt;span style="color:#719e07">.&lt;/span>matches&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 将 content 存入到 MatchPair 的 matches 集合中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> values&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 分隔符为 !=
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;!=&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>separator&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>pair &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ParseException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Illegal route rule ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
values &lt;span style="color:#719e07">=&lt;/span> pair&lt;span style="color:#719e07">.&lt;/span>mismatches&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 将 content 存入到 MatchPair 的 mismatches 集合中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> values&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 分隔符为 ,
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;,&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>separator&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>values &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> values&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ParseException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Illegal route rule ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 将 content 存入到上一步获取到的 values 中，可能是 matches，也可能是 mismatches
&lt;/span>&lt;span style="color:#586e75">&lt;/span> values&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>content&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ParseException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Illegal route rule ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> condition&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上就是路由规则的解析逻辑，该逻辑由正则表达式和一个 while 循环以及数个条件分支组成。下面通过一个示例对解析逻辑进行演绎。示例为 &lt;code> host = 2.2.2.2 &amp;amp; host != 1.1.1.1 &amp;amp; method = hello&lt;/code>。正则解析结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"> 括号一 括号二
1. null host
2. = 2.2.2.2
3. &amp;amp; host
4. != 1.1.1.1
5. &amp;amp; method
6. = hello
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在线程进入 while 循环：&lt;/p>
&lt;p>第一次循环：分隔符 separator = null，content = &amp;ldquo;host&amp;rdquo;。此时创建 MatchPair 对象，并存入到 condition 中，condition = {&amp;ldquo;host&amp;rdquo;: MatchPair@123}&lt;/p>
&lt;p>第二次循环：分隔符 separator = &amp;ldquo;=&amp;quot;，content = &amp;ldquo;2.2.2.2&amp;rdquo;，pair = MatchPair@123。此时将 2.2.2.2 放入到 MatchPair@123 对象的 matches 集合中。&lt;/p>
&lt;p>第三次循环：分隔符 separator = &amp;ldquo;&amp;amp;&amp;quot;，content = &amp;ldquo;host&amp;rdquo;。host 已存在于 condition 中，因此 pair = MatchPair@123。&lt;/p>
&lt;p>第四次循环：分隔符 separator = &amp;ldquo;!=&amp;quot;，content = &amp;ldquo;1.1.1.1&amp;rdquo;，pair = MatchPair@123。此时将 1.1.1.1 放入到 MatchPair@123 对象的 mismatches 集合中。&lt;/p>
&lt;p>第五次循环：分隔符 separator = &amp;ldquo;&amp;amp;&amp;quot;，content = &amp;ldquo;method&amp;rdquo;。condition.get(&amp;ldquo;method&amp;rdquo;) = null，因此新建一个 MatchPair 对象，并放入到 condition 中。此时 condition = {&amp;ldquo;host&amp;rdquo;: MatchPair@123, &amp;ldquo;method&amp;rdquo;: MatchPair@ 456}&lt;/p>
&lt;p>第六次循环：分隔符 separator = &amp;ldquo;=&amp;quot;，content = &amp;ldquo;2.2.2.2&amp;rdquo;，pair = MatchPair@456。此时将 hello 放入到 MatchPair@456 对象的 matches 集合中。&lt;/p>
&lt;p>循环结束，此时 condition 的内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#268bd2">&amp;#34;host&amp;#34;&lt;/span>: {
&lt;span style="color:#268bd2">&amp;#34;matches&amp;#34;&lt;/span>: [&lt;span style="color:#2aa198">&amp;#34;2.2.2.2&amp;#34;&lt;/span>],
&lt;span style="color:#268bd2">&amp;#34;mismatches&amp;#34;&lt;/span>: [&lt;span style="color:#2aa198">&amp;#34;1.1.1.1&amp;#34;&lt;/span>]
},
&lt;span style="color:#268bd2">&amp;#34;method&amp;#34;&lt;/span>: {
&lt;span style="color:#268bd2">&amp;#34;matches&amp;#34;&lt;/span>: [&lt;span style="color:#2aa198">&amp;#34;hello&amp;#34;&lt;/span>],
&lt;span style="color:#268bd2">&amp;#34;mismatches&amp;#34;&lt;/span>: []
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>路由规则的解析过程稍微有点复杂，大家可通过 ConditionRouter 的测试类对该逻辑进行测试。并且找一个表达式，对照上面的代码走一遍，加深理解。&lt;/p>
&lt;h3 id="22-服务路由">2.2 服务路由&lt;/h3>
&lt;p>服务路由的入口方法是 ConditionRouter 的 route 方法，该方法定义在 Router 接口中。实现代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#268bd2">route&lt;/span>&lt;span style="color:#719e07">(&lt;/span>List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> invokers&lt;span style="color:#719e07">,&lt;/span> URL url&lt;span style="color:#719e07">,&lt;/span> Invocation invocation&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>invokers &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> invokers&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> invokers&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 先对服务消费者条件进行匹配，如果匹配失败，表明服务消费者 url 不符合匹配规则，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// host = 10.20.153.10 =&amp;gt; host = 10.0.0.10
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>matchWhen&lt;span style="color:#719e07">(&lt;/span>url&lt;span style="color:#719e07">,&lt;/span> invocation&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> invokers&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;();&lt;/span>
&lt;span style="color:#586e75">// 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>thenCondition &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>warn&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;The current consumer in the service blacklist...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// Invoker 列表进行匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker &lt;span style="color:#719e07">:&lt;/span> invokers&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 若匹配成功，表明当前 Invoker 符合服务提供者匹配规则。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 此时将 Invoker 添加到 result 列表中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>matchThen&lt;span style="color:#719e07">(&lt;/span>invoker&lt;span style="color:#719e07">.&lt;/span>getUrl&lt;span style="color:#719e07">(),&lt;/span> url&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
result&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>invoker&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 否则路由结果为空的路由规则将自动失效
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>result&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>force&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>warn&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;The route result is empty and force execute ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
logger&lt;span style="color:#719e07">.&lt;/span>error&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Failed to execute condition router rule: ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 原样返回，此时 force = false，表示该条路由规则失效
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> invokers&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>route 方法先是调用 matchWhen 对服务消费者进行匹配，如果匹配失败，直接返回 Invoker 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 matchThen 方法中。下面来看一下这两个方法的逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">matchWhen&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">,&lt;/span> Invocation invocation&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 服务消费者条件为 null 或空，均返回 true，比如：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// =&amp;gt; host != 172.22.3.91
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 表示所有的服务消费者都不得调用 IP 为 172.22.3.91 的机器上的服务
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> whenCondition &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> whenCondition&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">()&lt;/span>
&lt;span style="color:#719e07">||&lt;/span> matchCondition&lt;span style="color:#719e07">(&lt;/span>whenCondition&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">,&lt;/span> invocation&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 进行条件匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">matchThen&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">,&lt;/span> URL param&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 服务提供者条件为 null 或空，表示禁用服务
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">!(&lt;/span>thenCondition &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> thenCondition&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> matchCondition&lt;span style="color:#719e07">(&lt;/span>thenCondition&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 进行条件匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这两个方法长的有点像，不过逻辑上还是有差别的，大家注意看。这两个方法均调用了 matchCondition 方法，但它们所传入的参数是不同的。这个需要特别注意一下，不然后面的逻辑不好弄懂。下面我们对这几个参数进行溯源。matchWhen 方法向 matchCondition 方法传入的参数为 [whenCondition, url, null, invocation]，第一个参数 whenCondition 为服务消费者匹配条件，这个前面分析过。第二个参数 url 源自 route 方法的参数列表，该参数由外部类调用 route 方法时传入。比如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#268bd2">route&lt;/span>&lt;span style="color:#719e07">(&lt;/span>List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> invokers&lt;span style="color:#719e07">,&lt;/span> String method&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Invocation invocation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RpcInvocation&lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[&lt;/span>0&lt;span style="color:#719e07">],&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Object&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">]);&lt;/span>
List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Router&lt;span style="color:#719e07">&amp;gt;&lt;/span> routers &lt;span style="color:#719e07">=&lt;/span> getRouters&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>routers &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Router router &lt;span style="color:#719e07">:&lt;/span> routers&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>router&lt;span style="color:#719e07">.&lt;/span>getUrl&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 注意第二个参数
&lt;/span>&lt;span style="color:#586e75">&lt;/span> invokers &lt;span style="color:#719e07">=&lt;/span> router&lt;span style="color:#719e07">.&lt;/span>route&lt;span style="color:#719e07">(&lt;/span>invokers&lt;span style="color:#719e07">,&lt;/span> getConsumerUrl&lt;span style="color:#719e07">(),&lt;/span> invocation&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> invokers&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这段代码来自 RegistryDirectory，第二个参数表示的是服务消费者 url。matchCondition 的 invocation 参数也是从这里传入的。&lt;/p>
&lt;p>接下来再来看看 matchThen 向 matchCondition 方法传入的参数 [thenCondition, url, param, null]。第一个参数不用解释了。第二个和第三个参数来自 matchThen 方法的参数列表，这两个参数分别为服务提供者 url 和服务消费者 url。搞清楚这些参数来源后，接下来就可以分析 matchCondition 方法了。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">matchCondition&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> condition&lt;span style="color:#719e07">,&lt;/span> URL url&lt;span style="color:#719e07">,&lt;/span> URL param&lt;span style="color:#719e07">,&lt;/span> Invocation invocation&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 将服务提供者或消费者 url 转成 Map
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> String&lt;span style="color:#719e07">&amp;gt;&lt;/span> sample &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>toMap&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#dc322f">boolean&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 遍历 condition 列表
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Map&lt;span style="color:#719e07">.&lt;/span>Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> MatchPair&lt;span style="color:#719e07">&amp;gt;&lt;/span> matchPair &lt;span style="color:#719e07">:&lt;/span> condition&lt;span style="color:#719e07">.&lt;/span>entrySet&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取匹配项名称，比如 host、method 等
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String key &lt;span style="color:#719e07">=&lt;/span> matchPair&lt;span style="color:#719e07">.&lt;/span>getKey&lt;span style="color:#719e07">();&lt;/span>
String sampleValue&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 如果 invocation 不为空，且 key 为 mehtod(s)，表示进行方法匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>invocation &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>METHOD_KEY&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>key&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">||&lt;/span> Constants&lt;span style="color:#719e07">.&lt;/span>METHODS_KEY&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>key&lt;span style="color:#719e07">)))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 从 invocation 获取被调用方法的名称
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sampleValue &lt;span style="color:#719e07">=&lt;/span> invocation&lt;span style="color:#719e07">.&lt;/span>getMethodName&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 从服务提供者或消费者 url 中获取指定字段值，比如 host、application 等
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sampleValue &lt;span style="color:#719e07">=&lt;/span> sample&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>key&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>sampleValue &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 尝试通过 default.xxx 获取相应的值
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sampleValue &lt;span style="color:#719e07">=&lt;/span> sample&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">(&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>DEFAULT_KEY_PREFIX &lt;span style="color:#719e07">+&lt;/span> key&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// --------------------✨ 分割线 ✨-------------------- //
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>sampleValue &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 调用 MatchPair 的 isMatch 方法进行匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>matchPair&lt;span style="color:#719e07">.&lt;/span>getValue&lt;span style="color:#719e07">().&lt;/span>isMatch&lt;span style="color:#719e07">(&lt;/span>sampleValue&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 只要有一个规则匹配失败，立即返回 false 结束方法逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// sampleValue 为空，表明服务提供者或消费者 url 中不包含相关字段。此时如果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// MatchPair 的 matches 不为空，表示匹配失败，返回 false。比如我们有这样
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 一条匹配条件 loadbalance = random，假设 url 中并不包含 loadbalance 参数，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 此时 sampleValue = null。既然路由规则里限制了 loadbalance 必须为 random，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 但 sampleValue = null，明显不符合规则，因此返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>matchPair&lt;span style="color:#719e07">.&lt;/span>getValue&lt;span style="color:#719e07">().&lt;/span>matches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，matchCondition 方法看起来有点复杂，这里简单说明一下。分割线以上的代码实际上用于获取 sampleValue 的值，分割线以下才是进行条件匹配。条件匹配调用的逻辑封装在 isMatch 中，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">isMatch&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String value&lt;span style="color:#719e07">,&lt;/span> URL param&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 情况一：matches 非空，mismatches 为空
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>matches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> mismatches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 遍历 matches 集合，检测入参 value 是否能被 matches 集合元素匹配到。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 举个例子，如果 value = 10.20.153.11，matches = [10.20.153.*],
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 此时 isMatchGlobPattern 方法返回 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String match &lt;span style="color:#719e07">:&lt;/span> matches&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>UrlUtils&lt;span style="color:#719e07">.&lt;/span>isMatchGlobPattern&lt;span style="color:#719e07">(&lt;/span>match&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 如果所有匹配项都无法匹配到入参，则返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 情况二：matches 为空，mismatches 非空
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>mismatches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> matches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String mismatch &lt;span style="color:#719e07">:&lt;/span> mismatches&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 只要入参被 mismatches 集合中的任意一个元素匹配到，就返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>UrlUtils&lt;span style="color:#719e07">.&lt;/span>isMatchGlobPattern&lt;span style="color:#719e07">(&lt;/span>mismatch&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// mismatches 集合中所有元素都无法匹配到入参，此时返回 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 情况三：matches 非空，mismatches 非空
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>matches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>mismatches&lt;span style="color:#719e07">.&lt;/span>isEmpty&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// matches 和 mismatches 均为非空，此时优先使用 mismatches 集合元素对入参进行匹配。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 只要 mismatches 集合中任意一个元素与入参匹配成功，就立即返回 false，结束方法逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String mismatch &lt;span style="color:#719e07">:&lt;/span> mismatches&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>UrlUtils&lt;span style="color:#719e07">.&lt;/span>isMatchGlobPattern&lt;span style="color:#719e07">(&lt;/span>mismatch&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// mismatches 集合元素无法匹配到入参，此时再使用 matches 继续匹配
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String match &lt;span style="color:#719e07">:&lt;/span> matches&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 只要 matches 集合中任意一个元素与入参匹配成功，就立即返回 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>UrlUtils&lt;span style="color:#719e07">.&lt;/span>isMatchGlobPattern&lt;span style="color:#719e07">(&lt;/span>match&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">,&lt;/span> param&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 全部失配，则返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 情况四：matches 和 mismatches 均为空，此时返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>isMatch 方法逻辑比较清晰，由三个条件分支组成，用于处理四种情况。这里对四种情况下的匹配逻辑进行简单的总结，如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>条件&lt;/th>
&lt;th>过程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>情况一&lt;/td>
&lt;td>matches 非空，mismatches 为空&lt;/td>
&lt;td>遍历 matches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，即可返回 true。若全部失配，则返回 false。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>情况二&lt;/td>
&lt;td>matches 为空，mismatches 非空&lt;/td>
&lt;td>遍历 mismatches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，立即 false。若全部失配，则返回 true。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>情况三&lt;/td>
&lt;td>matches 非空，mismatches 非空&lt;/td>
&lt;td>优先使用 mismatches 集合元素对入参进行匹配，只要任一元素与入参匹配成功，就立即返回 false，结束方法逻辑。否则再使用 matches 中的集合元素进行匹配，只要有任意一个元素匹配成功，即可返回 true。若全部失配，则返回 false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>情况四&lt;/td>
&lt;td>matches 为空，mismatches 为空&lt;/td>
&lt;td>直接返回 false&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>isMatch 方法是通过 UrlUtils 的 isMatchGlobPattern 方法进行匹配，因此下面我们再来看看 isMatchGlobPattern 方法的逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">isMatchGlobPattern&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String pattern&lt;span style="color:#719e07">,&lt;/span> String value&lt;span style="color:#719e07">,&lt;/span> URL param&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>param &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>startsWith&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;$&amp;#34;&lt;/span>&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 引用服务消费者参数，param 参数为服务消费者 url
&lt;/span>&lt;span style="color:#586e75">&lt;/span> pattern &lt;span style="color:#719e07">=&lt;/span> param&lt;span style="color:#719e07">.&lt;/span>getRawParameter&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>1&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 调用重载方法继续比较
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> isMatchGlobPattern&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">isMatchGlobPattern&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String pattern&lt;span style="color:#719e07">,&lt;/span> String value&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 对 * 通配符提供支持
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;*&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">))&lt;/span>
&lt;span style="color:#586e75">// 匹配规则为通配符 *，直接返回 true 即可
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">((&lt;/span>pattern &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">(&lt;/span>value &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">))&lt;/span>
&lt;span style="color:#586e75">// pattern 和 value 均为空，此时可认为两者相等，返回 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">((&lt;/span>pattern &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#719e07">(&lt;/span>value &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">))&lt;/span>
&lt;span style="color:#586e75">// pattern 和 value 其中有一个为空，表明两者不相等，返回 false
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 定位 * 通配符位置
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>lastIndexOf&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#39;*&amp;#39;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#719e07">-&lt;/span>1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 匹配规则中不包含通配符，此时直接比较 value 和 pattern 是否相等即可，并返回比较结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 通配符 &amp;#34;*&amp;#34; 在匹配规则尾部，比如 10.0.21.*
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">==&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">-&lt;/span> 1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测 value 是否以“不含通配符的匹配规则”开头，并返回结果。比如:
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// pattern = 10.0.21.*，value = 10.0.21.12，此时返回 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>startsWith&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 通配符 &amp;#34;*&amp;#34; 在匹配规则头部
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测 value 是否以“不含通配符的匹配规则”结尾，并返回结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>endsWith&lt;span style="color:#719e07">(&lt;/span>pattern&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">+&lt;/span> 1&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 通配符 &amp;#34;*&amp;#34; 在匹配规则中间位置
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 通过通配符将 pattern 分成两半，得到 prefix 和 suffix
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String prefix &lt;span style="color:#719e07">=&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">);&lt;/span>
String suffix &lt;span style="color:#719e07">=&lt;/span> pattern&lt;span style="color:#719e07">.&lt;/span>substring&lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">+&lt;/span> 1&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 检测 value 是否以 prefix 开头，且以 suffix 结尾，并返回结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>startsWith&lt;span style="color:#719e07">(&lt;/span>prefix&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>endsWith&lt;span style="color:#719e07">(&lt;/span>suffix&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上就是 isMatchGlobPattern 两个重载方法的全部逻辑，这两个方法分别对普通的匹配过程，以及”引用消费者参数“和通配符匹配等特性提供了支持。这两个方法的逻辑不是很复杂，且代码中也进行了比较详细的注释，因此就不多说了。&lt;/p>
&lt;h2 id="3-总结">3. 总结&lt;/h2>
&lt;p>本篇文章对条件路由的表达式解析和服务路由过程进行了较为细致的分析。总的来说，条件路由的代码还是有一些复杂的，需要静下心来看。在阅读条件路由代码的过程中，要多调试。一般的框架都会有单元测试，Dubbo 也不例外，因此大家可以直接通过 ConditionRouterTest 对条件路由进行调试，无需重头构建测试用例。&lt;/p></description></item><item><title>Docs: Apache 提交者注册流程</title><link>/zh/docs/contribution-guidelines/committer/new-committer-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/contribution-guidelines/committer/new-committer-guide_dev/</guid><description>
&lt;h2 id="一apache-提交者的产生">一、Apache 提交者的产生&lt;/h2>
&lt;h3 id="项目孵化初始化提交者">项目孵化初始化提交者&lt;/h3>
&lt;p>项目孵化阶段，在孵化项目提案中，会有初始化提交者列表这一选项。确认你是初始化提交者的一员。项目在 apache 孵化器社区投票通过后，提交者可以开始准备注册账户了。可以参看&lt;a href="https://wiki.apache.org/incubator/">孵化器 wiki&lt;/a>&lt;/p>
&lt;h3 id="活跃的贡献者被选举为提交者">活跃的贡献者被选举为提交者&lt;/h3>
&lt;p>在后期的开发过程中，活跃的贡献者可以被选举为提交者。见&lt;a href="https://www.apache.org/dev/new-committers-guide.html#becoming-a-committer">如何成为 committer&lt;/a>&lt;/p>
&lt;h2 id="二个人开发者提交-icla">二、个人开发者提交 ICLA&lt;/h2>
&lt;h3 id="1选择-apache-id">1、选择 apache id&lt;/h3>
&lt;p>在&lt;a href="http://people.apache.org/committer-index.html"> apache 提交者列表页&lt;/a>查看已经注册过的 apache id，&lt;/p>
&lt;h3 id="2个人提交者授权协议icla">2、个人提交者授权协议（ICLA）：&lt;/h3>
&lt;p>下载&lt;a href="https://www.apache.org/licenses/icla.pdf"> ICLA 模板&lt;/a>，查找可用的 id。将 icla.pdf 个人信息填写正确后打印,签名、扫描、并当做附件发送邮件给秘书 &lt;a href="mailto:secretary@apache.org">secretary@apache.org&lt;/a>，秘书会帮忙创建 apache 用户 id。同时会创建一个 &lt;a href="mailto:your_id@apache.org">your_id@apache.org&lt;/a> 的邮箱，可以在&lt;a href="http://people.apache.org/committer-index.html"> apache 提交者列表页&lt;/a>查看查找用户是否已经创建。&lt;/p>
&lt;h3 id="3导师帮助提交用户id创建请求">3、导师帮助提交用户id创建请求&lt;/h3>
&lt;p>导师将帮助提交 apache 账户创建请求给 root 邮件组，会有人帮助建立 id。一般需要2天时间账户会建立，请等待并在&lt;a href="http://people.apache.org/committer-index.html"> apache 提交者列表页&lt;/a>查看查找用户是否已经创建。&lt;/p>
&lt;h2 id="三加入apache开发者组">三、加入apache开发者组&lt;/h2>
&lt;ol>
&lt;li>登陆 &lt;a href="https://id.apache.org/">Apache 账户工具&lt;/a>，在登陆页面点击&amp;quot;忘记密码&amp;quot;设置始化密码，会有一封密码重置邮件发送到 forward 邮箱(在孵化项目提案中提交的开发者邮件)&lt;/li>
&lt;li>关于 apache 邮箱：apache.org 邮箱并没有自己的邮件内容存储服务器。它需要借用其他邮件提供商的邮件内容存储、分发功能。在很多投票环节是建议使用 apache 邮箱的。
这里就有一个问题，怎么在其它邮箱里面配置 apache.org 邮箱转发功能：
&lt;ul>
&lt;li>收件箱：收取发送到 apache.org 的邮件。这个在第一步配置好 Apache 账户工具的 forward 邮箱就可以用 forward 邮箱收取邮件了&lt;/li>
&lt;li>发件箱：将发出的邮件显示发件邮箱为 apache.org 邮箱。请参考：&lt;a href="https://reference.apache.org/committer/email">设置 apache 邮箱指南&lt;/a>和&lt;a href="http://gmailblog.blogspot.com/2009/07/send-mail-from-another-address-without.html"> gmail 邮箱设置方式&lt;/a>。 其他邮箱服务的设置方式不方便找到，gmail 的最方便，建议换成 gmail 邮箱(不是广告)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>修改编辑页面的 homepage url，&lt;a href="http://people.apache.org/committer-index.html">apache 提交者列表页&lt;/a>中你的账户能加主页链接。&lt;/li>
&lt;li>修改编辑页面的 github 账户(username)，提交确认后两个小时内会有邮件邀请你加入 github.com/apache-committers 组。这期间可以阅读&lt;a href="http://www.apache.org/foundation/how-it-works.html#developers"> ASF 工作方式&lt;/a>以对 ASF 开发做一些基本了解。&lt;/li>
&lt;/ol>
&lt;h2 id="四提交者获得对项目的写权限">四、提交者获得对项目的写权限&lt;/h2>
&lt;p>&lt;a href="https://gitbox.apache.org/setup/">GitBox 账户链接工具&lt;/a>的操作&lt;/p>
&lt;h3 id="apache账户授权">Apache账户授权&lt;/h3>
&lt;p>按照提示授权对 Apache 账户的 OAuth 协议登入&lt;/p>
&lt;h3 id="github账户授权">Github账户授权&lt;/h3>
&lt;p>按照提示授权对 github 账户的 OAuth 协议登入&lt;/p>
&lt;h3 id="在-githubcom-设置-github-账户两因素授权2fa">在 github.com 设置 github 账户两因素授权（2FA）&lt;/h3>
&lt;p>按照&lt;a href="https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/">授权 GitHub 2FA wiki&lt;/a> 操作如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在手机安装 “google 身份验证器” app&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按照&lt;a href="https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/">授权 GitHub 2FA wiki&lt;/a> 一步一步操作。&lt;/p>
&lt;p>在&lt;a href="https://github.com/settings/two_factor_authentication/verify">两因素授权验证&lt;/a>界面，不建议选择用手机扫描二维码，因为有些手机会扫描不出来。
请打开手机 “google 身份验证器” app，点“+”选择“输入提供的秘钥”： 在“账户名” input 框写入 github 账户。在“您的秘钥” input 框写入:打开的网页中 &amp;ldquo;enter this text code&amp;rdquo; 链接里面的文本。在 app 中点击&amp;quot;添加&amp;quot; 后，将为此账户生成6位数字动态。将此6位数字写入网页中的文本框，然后点 “Enable”。这样 2FA 就设置成功了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>退出并重新登陆 github，输入用户名、密码后会多一步动态密码的填写，该动态密码就是 google 身份验证器上面的动态密码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大概需要半个小时,会有邮件通知你已经加入了 xx project-committers 开发者组。你也可以进入 &lt;a href="https://github.com/orgs/apache/teams">apache teams&lt;/a> 页面查看。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2FA 提交后，你已经 clone 的项目会有权限校验问题，解决方法为下面二选一：&lt;/p>
&lt;ul>
&lt;li>申请 Access Token：
在 github 上生成 access token 后，指令行需要密码的地方就粘贴token。
参考官网&lt;a href="https://help.github.com/articles/https-cloning-errors/#provide-access-token-if-2fa-enabled">帮助链接一&lt;/a>和&lt;a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">帮助链接二&lt;/a>&lt;/li>
&lt;li>改用 ssh：
在命令行执行 ssh-keygen 命令， 然后把pub文件中的内容粘贴到 github 上&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>注意：一定要保证 github 的 2FA 为 &amp;ldquo;enable&amp;rdquo; 状态。当你将 2FA 设置为 &amp;ldquo;off&amp;rdquo; 时候，将会被对应的 apache committer 写权限组除名，直到你再次设置成功为止。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="五其他">五、其他&lt;/h2>
&lt;h3 id="the-apache-way">The Apache Way&lt;/h3>
&lt;p>详情请参考 &lt;a href="http://apache.org/foundation/governance/">wiki&lt;/a>&lt;/p>
&lt;p>社区重于代码，如果某问题或者方案没有在社区(邮件列表)讨论过，就当没有发生过&lt;/p>
&lt;h3 id="添加你的名字">添加你的名字&lt;/h3>
&lt;p>请访问孵化器&lt;a href="https://incubator.apache.org/projects/dubbo.html">主页&lt;/a>将你的名字添加到上面. 具体可以参考这个&lt;a href="http://dubbo.apache.org/docs/3.0/zh-cn/docs/developers/committer-guide/apache-dubbo-page_dev.html">文档&lt;/a>.&lt;/p>
&lt;p>请访问 Dubbo&lt;a href="http://dubbo.apache.org/docs/3.0/zh-cn/docs/developers/developers/developers_dev.html">官方网站&lt;/a> 将你的名字添加到上面.&lt;/p>
&lt;h3 id="小福利">小福利&lt;/h3>
&lt;p>Jetbrains 给 apache 提交者一个小福利，就是可以免费使用 idea 的全产品系列。具体注册地址为：https://www.jetbrains.com/shop/eform/apache?product=ALL&lt;/p>
&lt;h3 id="相关-wiki">相关 wiki&lt;/h3>
&lt;p>&lt;a href="https://www.apache.org/dev/new-committers-guide.html">https://www.apache.org/dev/new-committers-guide.html&lt;/a>&lt;/p></description></item><item><title>Docs: 源码构建</title><link>/zh/docs/v2.7/dev/build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/build/</guid><description>
&lt;h2 id="代码签出">代码签出&lt;/h2>
&lt;p>通过以下的这个命令签出最新的项目源码 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/apache/dubbo.git dubbo
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分支">分支&lt;/h2>
&lt;p>我们使用 master 作为主干版本的开发，使用分支作为维护版本。可以通过 &lt;a href="https://github.com/apache/dubbo/tags">https://github.com/apache/dubbo/tags&lt;/a> 来查看所有版本的标签。&lt;/p>
&lt;h2 id="构建">构建&lt;/h2>
&lt;p>Dubbo 使用 &lt;a href="http://maven.apache.org">maven&lt;/a> 作为构建工具。&lt;/p>
&lt;p>要求&lt;/p>
&lt;ul>
&lt;li>Java 1.5 以上的版本&lt;/li>
&lt;li>Maven 2.2.1 或者以上的版本&lt;/li>
&lt;/ul>
&lt;p>构建之前需要配置以下的 &lt;code>MAVEN_OPTS&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#b58900">export&lt;/span> &lt;span style="color:#268bd2">MAVEN_OPTS&lt;/span>&lt;span style="color:#719e07">=&lt;/span>-Xmx1024m -XX:MaxPermSize&lt;span style="color:#719e07">=&lt;/span>512m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令做一次构建&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn clean install
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过以下的构建命令来跳过单元测试&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn install -Dmaven.test.skip
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="构建源代码-jar-包">构建源代码 jar 包&lt;/h2>
&lt;p>通过以下命令以构建 Dubbo 的源代码 jar 包&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn clean source:jar install -Dmaven.test.skip
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且修改你的样例项目中的 dubbo 依赖为本地仓库的 SANPSHOT 版本，然后使用远程 debug 来调试 dubbo。&lt;/p>
&lt;h2 id="ide-支持">IDE 支持&lt;/h2>
&lt;p>使用以下命令来生成 IDE 的工程&lt;/p>
&lt;h3 id="intellij-idea">Intellij Idea&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn idea:idea
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="eclipse">eclipse&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn eclipse:eclipse
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 eclipse 中导入&lt;/p>
&lt;p>首先，需要在 eclipse 中配置 maven 仓库。通过 Preferences -&amp;gt; Java -&amp;gt; Build Path -&amp;gt; Classpath 定义 &lt;code>M2_REPO&lt;/code> 的 classpath 变量指向本地的 maven 仓库。 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>也可以通过以下的 maven 命令配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn eclipse:configure-workspace -Declipse.workspace&lt;span style="color:#719e07">=&lt;/span>/path/to/the/workspace/
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>也可以直接在 &lt;a href="https://github.com/apache/dubbo">https://github.com/apache/dubbo&lt;/a> 上浏览源代码 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>UNIX 下的路径是 ${HOME}/.m2/repository, Windows 下的路径是 C:\Documents and Settings&amp;lt;user&amp;gt;.m2\repository &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: 管理控制台安装</title><link>/zh/docs/v2.7/admin/install/admin-console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/admin/install/admin-console/</guid><description>
&lt;p>目前版本的管理控制台正在开发中，已经完成了服务查询和服务治理的功能，采用前后端分离的模式，具体的安装和使用步骤如下：&lt;/p>
&lt;p>安装:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/apache/dubbo-admin.git /var/tmp/dubbo-admin
&lt;span style="color:#b58900">cd&lt;/span> /var/tmp/dubbo-admin
mvn clean package
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">配置文件为：
dubbo-admin-backend/src/main/resources/application.properties
主要的配置有：
dubbo.registry.address&lt;span style="color:#719e07">=&lt;/span>zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn --projects dubbo-admin-backend spring-boot:run
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其他配置请访问 github 中的文档:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">https://github.com/apache/dubbo-admin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">http://127.0.0.1:8080
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>当前版本中未实现登录功能，会在后续版本加上 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: 管理控制台运维</title><link>/zh/docs/v2.7/admin/ops/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/admin/ops/functions/</guid><description>
&lt;h2 id="搜索页面">搜索页面&lt;/h2>
&lt;p>当你需要管理 Dubbo 的服务时，首先要搜索到这个服务，然后打开它的管理页面&lt;/p>
&lt;p>&lt;img src="/imgs/admin/dubbo-search.jpg" alt="/admin-guide/images/dubbo-search.png">&lt;/p>
&lt;h2 id="服务提供者页面">服务提供者页面&lt;/h2>
&lt;p>&lt;img src="/imgs/admin/dubbo-providers.jpg" alt="/admin-guide/images/dubbo-providers.png">&lt;/p>
&lt;h2 id="服务消费者页面">服务消费者页面&lt;/h2>
&lt;p>&lt;img src="/imgs/admin/dubbo-consumers.jpg" alt="/admin-guide/images/dubbo-consumers.png">&lt;/p>
&lt;h2 id="添加路由规则页面">添加路由规则页面&lt;/h2>
&lt;p>&lt;img src="/imgs/admin/dubbo-add-route.jpg" alt="/admin-guide/images/dubbo-add-route.png">&lt;/p>
&lt;h2 id="添加动态配置页面">添加动态配置页面&lt;/h2>
&lt;p>&lt;img src="/imgs/admin/dubbo-add-config.jpg" alt="/admin-guide/images/dubbo-add-config.png">&lt;/p></description></item><item><title>Docs: 背景</title><link>/zh/docs/v2.7/user/preface/background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/preface/background/</guid><description>
&lt;p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。&lt;/p>
&lt;p>&lt;img src="/imgs/user/dubbo-architecture-roadmap.jpg" alt="image">&lt;/p>
&lt;h4 id="单一应用架构">单一应用架构&lt;/h4>
&lt;p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。&lt;/p>
&lt;h4 id="垂直应用架构">垂直应用架构&lt;/h4>
&lt;p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。&lt;/p>
&lt;h4 id="分布式服务架构">分布式服务架构&lt;/h4>
&lt;p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。&lt;/p>
&lt;h4 id="流动计算架构">流动计算架构&lt;/h4>
&lt;p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。&lt;/p></description></item><item><title>Docs: 需求</title><link>/zh/docs/v2.7/user/preface/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/preface/requirements/</guid><description>
&lt;p>&lt;img src="/imgs/user/dubbo-service-governance.jpg" alt="image">&lt;/p>
&lt;p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。&lt;/p>
&lt;p>&lt;strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。&lt;/strong> 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。&lt;/p>
&lt;p>&lt;strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。&lt;/strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。&lt;/p>
&lt;p>&lt;strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？&lt;/strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。&lt;/p>
&lt;p>以上是 Dubbo 最基本的几个需求。&lt;/p></description></item><item><title>Docs: 魔鬼在细节</title><link>/zh/docs/v2.7/dev/principals/code-detail/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/principals/code-detail/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="http://javatar.iteye.com/blog/1056664">http://javatar.iteye.com/blog/1056664&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>最近一直担心如果 Dubbo 分布式服务框架维护人员增多或变更，会出现质量的下降的问题， 我在想，有没有什么规则是需要大家共同遵守的。根据平时写代码时的一习惯，总结了以下在写代码过程中，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的， 大家经常说，魔鬼在细节中，确实如此。&lt;/p>
&lt;h2 id="防止空指针和下标越界">防止空指针和下标越界&lt;/h2>
&lt;p>这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。&lt;/p>
&lt;h2 id="保证线程安全性和可见性">保证线程安全性和可见性&lt;/h2>
&lt;p>对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。&lt;/p>
&lt;h2 id="尽早失败和前置断言">尽早失败和前置断言&lt;/h2>
&lt;p>尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。&lt;/p>
&lt;h2 id="分离可靠操作和不可靠操作">分离可靠操作和不可靠操作&lt;/h2>
&lt;p>这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。&lt;/p>
&lt;h2 id="异常防御但不忽略异常">异常防御，但不忽略异常&lt;/h2>
&lt;p>这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。&lt;/p>
&lt;h2 id="缩小可变域和尽量-final">缩小可变域和尽量 final&lt;/h2>
&lt;p>如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。&lt;/p>
&lt;h2 id="降低修改时的误解性不埋雷">降低修改时的误解性，不埋雷&lt;/h2>
&lt;p>前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。&lt;/p>
&lt;h2 id="提高代码的可测性">提高代码的可测性&lt;/h2>
&lt;p>这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。&lt;/p></description></item><item><title>Docs: CLA 签署向导</title><link>/zh/docs/contribution-guidelines/contributor/cla-signing-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/contribution-guidelines/contributor/cla-signing-guide_dev/</guid><description>
&lt;p>以下情况，需要您签署 Apache ICLA：&lt;/p>
&lt;ul>
&lt;li>在 Dubbo 被捐赠给 Apache 之前，您已经为 Dubbo 作出了很多贡献，并且您以前没有签署过 Alibaba-CLA。&lt;/li>
&lt;li>您已经为 Dubbo 作出了很多贡献，并且您被邀请成为 Dubbo 提交者，且之前没有签署过 Alibaba-CLA 或者 Apache ICLA。&lt;/li>
&lt;/ul>
&lt;h3 id="步骤">步骤&lt;/h3>
&lt;ul>
&lt;li>下载这篇 &lt;a href="https://www.apache.org/licenses/icla.pdf">pdf 文档&lt;/a>&lt;/li>
&lt;li>编辑该文档，在必要的空格处填上适当的内容&lt;/li>
&lt;li>打印&lt;/li>
&lt;li>在打印好的文件上签字&lt;/li>
&lt;li>扫描&lt;/li>
&lt;li>发送一封邮件到secretary@apache.org，并抄送给private@dubbo.apache.org：
&lt;ul>
&lt;li>邮件标题为“ICLA submission”&lt;/li>
&lt;li>请在邮件正文附上您的github账号链接&lt;/li>
&lt;li>请记得将您的ICLA文档放入邮件的附件里&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="空格填写必要说明">空格填写必要说明&lt;/h3>
&lt;ul>
&lt;li>Mailing address：首选英文格式的公司地址&lt;/li>
&lt;li>preferred apache id(s)：如果您被邀请成为一名提交者，那么需要您填写一个apache账号，否则，可以不填&lt;/li>
&lt;li>notify project：Dubbo（意思就是Dubbo就是通知您签署ICLA的项目）&lt;/li>
&lt;/ul></description></item><item><title>Docs: Dubbo 管理控制台介绍</title><link>/zh/docs/v2.7/admin/ops/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/admin/ops/introduction/</guid><description>
&lt;p>目前的管理控制台已经发布 0.1 版本，结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和UI框架，后端采用 Spring Boot 框架。既可以按照标准的 Maven 方式进行打包，部署，也可以采用前后端分离的部署方式，方便开发，功能上，目前具备了服务查询，服务治理(包括 Dubbo 2.7 中新增的治理规则)以及服务测试三部分内容。&lt;/p>
&lt;h3 id="maven方式部署">Maven方式部署&lt;/h3>
&lt;ul>
&lt;li>安装&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/apache/dubbo-admin.git
&lt;span style="color:#b58900">cd&lt;/span> dubbo-admin
mvn clean package
&lt;span style="color:#b58900">cd&lt;/span> dubbo-admin-distribution/target
java -jar dubbo-admin-0.1.jar
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>访问&lt;/li>
&lt;/ul>
&lt;p>http://localhost:8080&lt;/p>
&lt;h3 id="前后端分离部署">前后端分离部署&lt;/h3>
&lt;ul>
&lt;li>前端&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#b58900">cd&lt;/span> dubbo-admin-ui
npm install
npm run dev
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>后端&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#b58900">cd&lt;/span> dubbo-admin-server
mvn clean package
&lt;span style="color:#b58900">cd&lt;/span> target
java -jar dubbo-admin-server-0.1.jar
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>访问&lt;/li>
&lt;/ul>
&lt;p>http://localhost:8081&lt;/p>
&lt;ul>
&lt;li>前后端分离模式下，前端的修改可以实时生效&lt;/li>
&lt;/ul>
&lt;h3 id="配置-1">配置: &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/h3>
&lt;p>配置文件为：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">dubbo-admin-server/src/main/resources/application.properties
&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要的配置有：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">admin.config-center=zookeeper://127.0.0.1:2181
admin.registry.address=zookeeper://127.0.0.1:2181
admin.metadata-report.address=zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;p>三个配置项分别指定了配置中心，注册中心和元数据中心的地址，关于这三个中心的详细说明，可以参考&lt;a href="../../../user/configuration/config-center">这里&lt;/a>。&lt;/p>
&lt;p>也可以和 Dubbo 2.7 一样，在配置中心指定元数据和注册中心的地址，以 zookeeper 为例，配置的路径和内容如下:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># /dubbo/config/dubbo/dubbo.properties
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.metadata-report.address=zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置中心里的地址会覆盖掉本地 &lt;code>application.properties&lt;/code> 的配置&lt;/p>
&lt;p>其他配置请访问 github 中的文档:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">https://github.com/apache/dubbo-admin
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>当前版本中未实现登录功能，会在后续版本加上 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: Multicast 注册中心</title><link>/zh/docs/v2.7/user/references/registry/multicast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/registry/multicast/</guid><description>
&lt;p>Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。&lt;/p>
&lt;p>&lt;img src="/imgs/user/multicast.jpg" alt="/user-guide/images/multicast.jpg">&lt;/p>
&lt;ol start="0">
&lt;li>提供方启动时广播自己的地址&lt;/li>
&lt;li>消费方启动时广播订阅请求&lt;/li>
&lt;li>提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 &lt;code>unicast=false&lt;/code>，则广播给订阅者&lt;/li>
&lt;li>消费方收到提供方地址时，连接该地址进行 RPC 调用。&lt;/li>
&lt;/ol>
&lt;p>组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;multicast://224.5.6.7:1234&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;multicast&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;224.5.6.7:1234&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 &lt;code>unicast=false&lt;/code>，否则只会有一个消费者能收到消息;当服务者和消费者运行在同一台机器上，消费者同样需要声明&lt;code>unicast=false&lt;/code>，否则消费者无法收到消息，导致No provider available for the service异常：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;multicast://224.5.6.7:1234?unicast=false&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;multicast&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;224.5.6.7:1234&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:parameter&lt;/span> key=&lt;span style="color:#2aa198">&amp;#34;unicast&amp;#34;&lt;/span> value=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:registry&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: rest 协议</title><link>/zh/docs/v2.7/user/references/protocol/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/protocol/rest/</guid><description>
&lt;p>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持&lt;/p>
&lt;h2 id="快速入门">快速入门&lt;/h2>
&lt;p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。&lt;/p>
&lt;p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">http://localhost:8080/users/register
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。&lt;/p>
&lt;p>首先，开发服务的接口：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">UserService&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，开发服务的实现：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/users&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">UserServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> UserService &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@POST&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/register&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Consumes&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// save the user...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。&lt;/p>
&lt;p>@Path(&amp;quot;/users&amp;quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users&lt;/p>
&lt;p>@Path(&amp;quot;/register&amp;quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register&lt;/p>
&lt;p>@POST：指定访问registerUser()用HTTP POST方法&lt;/p>
&lt;p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象&lt;/p>
&lt;p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#586e75">&amp;lt;!-- 用rest协议在8080端口暴露服务 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8080&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;xxx.UserService&amp;#34;&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;userService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 和本地bean一样实现服务 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;userService&amp;#34;&lt;/span> class=&lt;span style="color:#2aa198">&amp;#34;xxx.UserServiceImpl&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="rest服务提供端详解">REST服务提供端详解&lt;/h2>
&lt;p>下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。&lt;/p>
&lt;h3 id="http-postget的实现">HTTP POST/GET的实现&lt;/h3>
&lt;p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。&lt;/p>
&lt;p>前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。&lt;/p>
&lt;p>这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">http://localhost:8080/users/load?id=1001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（http://localhost:8080/users/1001） 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@GET&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/{id : \\d+}&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>@GET：指定用HTTP GET方法访问&lt;/p>
&lt;p>@Path(&amp;quot;/{id : \d+}&amp;quot;)：根据上面的功能需求，访问getUser()的URL应当是“http://localhost:8080/users/ + 任意数字&amp;quot;，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，@Path中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam(&amp;ldquo;id&amp;rdquo;)修饰的方法参数id。{id:后面紧跟的\d+是一个正则表达式，指定了id参数必须是数字。&lt;/p>
&lt;p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。&lt;/p>
&lt;h3 id="annotation放在接口类还是实现类">Annotation放在接口类还是实现类&lt;/h3>
&lt;p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/users&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">UserService&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@GET&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/{id : \\d+}&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">})&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。&lt;/p>
&lt;p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。&lt;/p>
&lt;p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。&lt;/p>
&lt;h3 id="jsonxml等多数据格式的支持">JSON、XML等多数据格式的支持&lt;/h3>
&lt;p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。&lt;/p>
&lt;p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">,&lt;/span> MediaType&lt;span style="color:#719e07">.&lt;/span>TEXT_XML&lt;span style="color:#719e07">})&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者也可以直接用字符串（还支持通配符）表示MediaType：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>&lt;span style="color:#2aa198">&amp;#34;application/json&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;text/xml&amp;#34;&lt;/span>&lt;span style="color:#719e07">})&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/users&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Consumes&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">,&lt;/span> MediaType&lt;span style="color:#719e07">.&lt;/span>TEXT_XML&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">,&lt;/span> MediaType&lt;span style="color:#719e07">.&lt;/span>TEXT_XML&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">UserServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> UserService &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。&lt;/p>
&lt;p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。&lt;/p>
&lt;p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。&lt;/p>
&lt;blockquote>
&lt;p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。&lt;/p>
&lt;/blockquote>
&lt;h3 id="中文字符支持">中文字符支持&lt;/h3>
&lt;p>为了在dubbo REST中正常输出中文字符，和通常的Java web应用一样，我们需要将HTTP响应的contentType设置为UTF-8编码。&lt;/p>
&lt;p>基于JAX-RS的标准用法，我们只需要做如下annotation配置即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>&lt;span style="color:#2aa198">&amp;#34;application/json; charset=UTF-8&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;text/xml; charset=UTF-8&amp;#34;&lt;/span>&lt;span style="color:#719e07">})&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了方便用户，我们在dubbo REST中直接添加了一个支持类，来定义以上的常量，可以直接使用，减少出错的可能性。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Produces&lt;/span>&lt;span style="color:#719e07">({&lt;/span>ContentType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON_UTF_8&lt;span style="color:#719e07">,&lt;/span> ContentType&lt;span style="color:#719e07">.&lt;/span>TEXT_XML_UTF_8&lt;span style="color:#719e07">})&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="xml数据格式的额外要求">XML数据格式的额外要求&lt;/h3>
&lt;p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@XmlRootElement&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">User&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Serializable &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。&lt;/p>
&lt;p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#dc322f">long&lt;/span> &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@XmlRootElement&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">RegistrationResult&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Serializable &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">private&lt;/span> Long id&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">RegistrationResult&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">RegistrationResult&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Long id&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>id &lt;span style="color:#719e07">=&lt;/span> id&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> Long &lt;span style="color:#268bd2">getId&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> id&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setId&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Long id&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>id &lt;span style="color:#719e07">=&lt;/span> id&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并修改service方法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">RegistrationResult &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">{&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">:&lt;/span> &lt;span style="color:#2aa198">1001&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不加wrapper，JSON返回值将直接是&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">1001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而在XML中，加wrapper后返回值将是：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;registrationResult&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;id&amp;gt;&lt;/span>1002&lt;span style="color:#268bd2">&amp;lt;/id&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/registrationResult&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。&lt;/p>
&lt;h3 id="定制序列化">定制序列化&lt;/h3>
&lt;p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。&lt;/p>
&lt;p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。&lt;/p>
&lt;p>例如，定制对象属性映射到XML元素的名字：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@XmlRootElement&lt;/span>
&lt;span style="color:#268bd2">@XmlAccessorType&lt;/span>&lt;span style="color:#719e07">(&lt;/span>XmlAccessType&lt;span style="color:#719e07">.&lt;/span>FIELD&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">User&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Serializable &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@XmlElement&lt;/span>&lt;span style="color:#719e07">(&lt;/span>name&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;username&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">private&lt;/span> String name&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>定制对象属性映射到JSON字段的名字：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">User&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Serializable &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@JsonProperty&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;username&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">private&lt;/span> String name&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多资料请参考JAXB和Jackson的官方文档，或自行google。&lt;/p>
&lt;h3 id="配置rest-server的实现">配置REST Server的实现&lt;/h3>
&lt;p>目前在dubbo中，我们支持5种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server可以通过如下配置实现：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;jetty&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty和后面所述的tomcat、tjws，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，你可以直接默认采用jetty即可。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;tomcat&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上配置选用了嵌入式的tomcat来做rest server。在嵌入式tomcat上，REST的性能比jetty上要好得多（参见后面的基准测试），建议在需要高性能的场景下采用tomcat。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;tjws&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span> (tjws is now deprecated)
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;sunhttp&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。 注：tjws目前已经被deprecated掉了，因为它不能很好的和servlet 3.1 API工作。&lt;/p>
&lt;p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;servlet&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;web-app&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;context-param&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;param-name&amp;gt;&lt;/span>contextConfigLocation&lt;span style="color:#268bd2">&amp;lt;/param-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;param-value&amp;gt;&lt;/span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml&lt;span style="color:#268bd2">&amp;lt;/param-value&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/context-param&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;listener&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;listener-class&amp;gt;&lt;/span>org.apache.dubbo.remoting.http.servlet.BootstrapListener&lt;span style="color:#268bd2">&amp;lt;/listener-class&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/listener&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;listener&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;listener-class&amp;gt;&lt;/span>org.springframework.web.context.ContextLoaderListener&lt;span style="color:#268bd2">&amp;lt;/listener-class&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/listener&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-name&amp;gt;&lt;/span>dispatcher&lt;span style="color:#268bd2">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-class&amp;gt;&lt;/span>org.apache.dubbo.remoting.http.servlet.DispatcherServlet&lt;span style="color:#268bd2">&amp;lt;/servlet-class&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;load-on-startup&amp;gt;&lt;/span>1&lt;span style="color:#268bd2">&amp;lt;/load-on-startup&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servlet&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-name&amp;gt;&lt;/span>dispatcher&lt;span style="color:#268bd2">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;url-pattern&amp;gt;&lt;/span>/*&lt;span style="color:#268bd2">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/web-app&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。&lt;/p>
&lt;blockquote>
&lt;p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。&lt;/p>
&lt;/blockquote>
&lt;p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。&lt;/p>
&lt;h3 id="获取上下文context信息">获取上下文（Context）信息&lt;/h3>
&lt;p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。&lt;/p>
&lt;p>在dubbo的REST中，我们有两种方式获取客户端IP。&lt;/p>
&lt;p>第一种方式，用JAX-RS标准的@Context annotation：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#268bd2">@Context&lt;/span> HttpServletRequest request&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Client address is &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> request&lt;span style="color:#719e07">.&lt;/span>getRemoteAddr&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。&lt;/p>
&lt;blockquote>
&lt;p>注意：这种方式只能在将server设置为 tjws、tomcat、jetty 或者 servlet 的时候才能工作，因为只有这几种 server 的实现才提供了 servlet 容器。另外，标准的JAX-RS还支持用@Context修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。&lt;/p>
&lt;/blockquote>
&lt;p>第二种方式，用dubbo中常用的RpcContext：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@PathParam&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Client address is &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRemoteAddressString&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：这种方式只能在设置server=&amp;ldquo;jetty&amp;quot;或者server=&amp;ldquo;tomcat&amp;quot;或者server=&amp;ldquo;servlet&amp;quot;或者server=&amp;ldquo;tjws&amp;quot;的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。&lt;/p>
&lt;/blockquote>
&lt;p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。&lt;/p>
&lt;p>此外，在最新的dubbo rest中，还支持通过RpcContext来获取HttpServletRequest和HttpServletResponse，以提供更大的灵活性来方便用户实现某些复杂功能，比如在dubbo标准的filter中访问HTTP Header。用法示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRequest&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRequest&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">instanceof&lt;/span> HttpServletRequest&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Client address is &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#719e07">((&lt;/span>HttpServletRequest&lt;span style="color:#719e07">)&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRequest&lt;span style="color:#719e07">()).&lt;/span>getRemoteAddr&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getResponse&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getResponse&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">instanceof&lt;/span> HttpServletResponse&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Response object from RpcContext: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getResponse&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：为了保持协议的中立性，RpcContext.getRequest()和RpcContext.getResponse()返回的仅仅是一个Object类，而且可能为null。所以，你必须自己做null和类型的检查。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>注意：只有在设置server=&amp;ldquo;jetty&amp;quot;或者server=&amp;ldquo;tomcat&amp;quot;或者server=&amp;ldquo;servlet&amp;quot;的时候，你才能通过以上方法正确的得到HttpServletRequest和HttpServletResponse，因为只有这几种server实现了servlet容器。&lt;/p>
&lt;/blockquote>
&lt;p>为了简化编程，在此你也可以用泛型的方式来直接获取特定类型的request/response：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRequest&lt;span style="color:#719e07">(&lt;/span>HttpServletRequest&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Client address is &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getRequest&lt;span style="color:#719e07">(&lt;/span>HttpServletRequest&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">).&lt;/span>getRemoteAddr&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getResponse&lt;span style="color:#719e07">(&lt;/span>HttpServletResponse&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Response object from RpcContext: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext&lt;span style="color:#719e07">.&lt;/span>getContext&lt;span style="color:#719e07">().&lt;/span>getResponse&lt;span style="color:#719e07">(&lt;/span>HttpServletResponse&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果request/response不符合指定的类型，这里也会返回null。&lt;/p>
&lt;h3 id="配置端口号和context-path">配置端口号和Context Path&lt;/h3>
&lt;p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，如前所述，我们可以用@Path来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。&lt;/p>
&lt;p>只需要添加如下contextpath属性即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> contextpath=&lt;span style="color:#2aa198">&amp;#34;services&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前面代码为例：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/users&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">UserServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> UserService &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@POST&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/register&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Consumes&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// save the user...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在registerUser()的完整访问路径为：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">http://localhost:8888/services/users/register
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：如果你是选用外部应用服务器做rest server，即配置:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> contextpath=&lt;span style="color:#2aa198">&amp;#34;services&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;servlet&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的上下文路径（即webapp path加上servlet url pattern）保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的&lt;code>&amp;lt;url-pattern/&amp;gt;&lt;/code>完全一致：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-name&amp;gt;&lt;/span>dispatcher&lt;span style="color:#268bd2">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;url-pattern&amp;gt;&lt;/span>/services/*&lt;span style="color:#268bd2">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置线程数和io线程数">配置线程数和IO线程数&lt;/h3>
&lt;p>可以为rest服务配置线程池大小：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> threads=&lt;span style="color:#2aa198">&amp;#34;500&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：目前线程池的设置只有当server=&amp;ldquo;netty&amp;quot;或者server=&amp;ldquo;jetty&amp;quot;或者server=&amp;ldquo;tomcat&amp;quot;的时候才能生效。另外，如果server=&amp;ldquo;servlet&amp;rdquo;，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。&lt;/p>
&lt;/blockquote>
&lt;p>如果是选用netty server，还可以配置Netty的IO worker线程数：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> iothreads=&lt;span style="color:#2aa198">&amp;#34;5&amp;#34;&lt;/span> threads=&lt;span style="color:#2aa198">&amp;#34;100&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置长连接">配置长连接&lt;/h3>
&lt;p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> keepalive=&lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：这个配置目前只对server=&amp;ldquo;netty&amp;quot;和server=&amp;ldquo;tomcat&amp;quot;才能生效。&lt;/p>
&lt;/blockquote>
&lt;h3 id="配置最大的http连接数">配置最大的HTTP连接数&lt;/h3>
&lt;p>可以配置服务器提供端所能同时接收的最大HTTP连接数，防止REST server被过多连接撑爆，以作为一种最基本的自我保护机制：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> accepts=&lt;span style="color:#2aa198">&amp;#34;500&amp;#34;&lt;/span> server=&lt;span style="color:#2aa198">&amp;#34;tomcat/&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：这个配置目前只对server=&amp;ldquo;tomcat&amp;quot;才能生效。&lt;/p>
&lt;/blockquote>
&lt;h3 id="配置每个消费端的超时时间和http连接数">配置每个消费端的超时时间和HTTP连接数&lt;/h3>
&lt;p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> timeout=&lt;span style="color:#2aa198">&amp;#34;2000&amp;#34;&lt;/span> connections=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> timeout=&lt;span style="color:#2aa198">&amp;#34;2000&amp;#34;&lt;/span> connections=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”&lt;/p>
&lt;blockquote>
&lt;p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里&lt;code>&amp;lt;dubbo:service/&amp;gt;&lt;/code>上的配置完全无效，因为这种客户端不受dubbo控制。&lt;/p>
&lt;/blockquote>
&lt;h3 id="用annotation取代部分spring-xml配置">用Annotation取代部分Spring XML配置&lt;/h3>
&lt;p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Service&lt;/span>&lt;span style="color:#719e07">(&lt;/span>protocol &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/users&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">UserServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> UserService &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Autowired&lt;/span>
&lt;span style="color:#268bd2">private&lt;/span> UserRepository userRepository&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">@POST&lt;/span>
&lt;span style="color:#268bd2">@Path&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;/register&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Consumes&lt;/span>&lt;span style="color:#719e07">({&lt;/span>MediaType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>User user&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// save the user
&lt;/span>&lt;span style="color:#586e75">&lt;/span> userRepository&lt;span style="color:#719e07">.&lt;/span>save&lt;span style="color:#719e07">(&lt;/span>user&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>annotation的配置更简单更精确，通常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码的侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。&lt;/p>
&lt;p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。&lt;/p>
&lt;h3 id="添加自定义的filterinterceptor等">添加自定义的Filter、Interceptor等&lt;/h3>
&lt;p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。&lt;/p>
&lt;p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">CacheControlFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ContainerResponseFilter &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">filter&lt;/span>&lt;span style="color:#719e07">(&lt;/span>ContainerRequestContext req&lt;span style="color:#719e07">,&lt;/span> ContainerResponseContext res&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>req&lt;span style="color:#719e07">.&lt;/span>getMethod&lt;span style="color:#719e07">().&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;GET&amp;#34;&lt;/span>&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
res&lt;span style="color:#719e07">.&lt;/span>getHeaders&lt;span style="color:#719e07">().&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Cache-Control&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;someValue&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">GZIPWriterInterceptor&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> WriterInterceptor &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">aroundWriteTo&lt;/span>&lt;span style="color:#719e07">(&lt;/span>WriterInterceptorContext context&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">throws&lt;/span> IOException&lt;span style="color:#719e07">,&lt;/span> WebApplicationException &lt;span style="color:#719e07">{&lt;/span>
OutputStream outputStream &lt;span style="color:#719e07">=&lt;/span> context&lt;span style="color:#719e07">.&lt;/span>getOutputStream&lt;span style="color:#719e07">();&lt;/span>
context&lt;span style="color:#719e07">.&lt;/span>setOutputStream&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#719e07">new&lt;/span> GZIPOutputStream&lt;span style="color:#719e07">(&lt;/span>outputStream&lt;span style="color:#719e07">));&lt;/span>
context&lt;span style="color:#719e07">.&lt;/span>proceed&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加@Provider annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> extension=&lt;span style="color:#2aa198">&amp;#34;xxx.TraceInterceptor, xxx.TraceFilter&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在此，我们可以将Filter、Interceptor和DynamicFeature这三种类型的对象都添加到&lt;code>extension&lt;/code>属性上，多个之间用逗号分隔。（DynamicFeature是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）&lt;/p>
&lt;p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。&lt;/p>
&lt;blockquote>
&lt;p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。&lt;/p>
&lt;/blockquote>
&lt;p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">LoggingFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ClientResponseFilter &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">filter&lt;/span>&lt;span style="color:#719e07">(&lt;/span>ClientRequestContext reqCtx&lt;span style="color:#719e07">,&lt;/span> ClientResponseContext resCtx&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> IOException &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;status: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getStatus&lt;span style="color:#719e07">());&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;date: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getDate&lt;span style="color:#719e07">());&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;last-modified: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getLastModified&lt;span style="color:#719e07">());&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;location: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getLocation&lt;span style="color:#719e07">());&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;headers:&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> header &lt;span style="color:#719e07">:&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getHeaders&lt;span style="color:#719e07">().&lt;/span>entrySet&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>print&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\t&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> header&lt;span style="color:#719e07">.&lt;/span>getKey&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; :&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>String value &lt;span style="color:#719e07">:&lt;/span> header&lt;span style="color:#719e07">.&lt;/span>getValue&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>print&lt;span style="color:#719e07">(&lt;/span>value &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>print&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;media-type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resCtx&lt;span style="color:#719e07">.&lt;/span>getMediaType&lt;span style="color:#719e07">().&lt;/span>getType&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加自定义的exception处理">添加自定义的Exception处理&lt;/h3>
&lt;p>Dubbo的REST也支持JAX-RS标准的ExceptionMapper，可以用来定制特定exception发生后应该返回的HTTP响应。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">CustomExceptionMapper&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ExceptionMapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>NotFoundException&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> Response &lt;span style="color:#268bd2">toResponse&lt;/span>&lt;span style="color:#719e07">(&lt;/span>NotFoundException e&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> Response&lt;span style="color:#719e07">.&lt;/span>status&lt;span style="color:#719e07">(&lt;/span>Response&lt;span style="color:#719e07">.&lt;/span>Status&lt;span style="color:#719e07">.&lt;/span>NOT_FOUND&lt;span style="color:#719e07">).&lt;/span>entity&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Oops! the requested resource is not found!&amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>type&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;text/plain&amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>build&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>和Interceptor、Filter类似，将其添加到XML配置文件中即可启用：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> extension=&lt;span style="color:#2aa198">&amp;#34;xxx.CustomExceptionMapper&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置http日志输出">配置HTTP日志输出&lt;/h3>
&lt;p>Dubbo rest支持输出所有HTTP请求/响应中的header字段和body消息体。&lt;/p>
&lt;p>在XML配置中添加如下自带的REST filter：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> extension=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后配置在logging配置中至少为org.apache.dubbo.rpc.protocol.rest.support打开INFO级别日志输出，例如，在log4j.xml中配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;logger&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.rpc.protocol.rest.support&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;level&lt;/span> value=&lt;span style="color:#2aa198">&amp;#34;INFO&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;appender-ref&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;CONSOLE&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/logger&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，你也可以直接在ROOT logger打开INFO级别日志输出：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;root&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;level&lt;/span> value=&lt;span style="color:#2aa198">&amp;#34;INFO&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;appender-ref&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;CONSOLE&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/root&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在日志中会有类似如下的内容输出：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">The HTTP headers are:
accept: application/json;charset=UTF-8
accept-encoding: gzip, deflate
connection: Keep-Alive
content-length: 22
content-type: application/json
host: 192.168.1.100:8888
user-agent: Apache-HttpClient/4.2.1 (java 1.5)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">The contents of request body is:
{&amp;#34;id&amp;#34;:1,&amp;#34;name&amp;#34;:&amp;#34;dang&amp;#34;}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>打开HTTP日志输出后，除了正常日志输出的性能开销外，也会在比如HTTP请求解析时产生额外的开销，因为需要建立额外的内存缓冲区来为日志的输出做数据准备。&lt;/p>
&lt;h3 id="输入参数的校验">输入参数的校验&lt;/h3>
&lt;p>dubbo的rest支持采用Java标准的bean validation annotation（JSR 303)来做输入校验http://beanvalidation.org/&lt;/p>
&lt;p>为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">UserService&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
User &lt;span style="color:#268bd2">getUser&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#268bd2">@Min&lt;/span>&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">=&lt;/span>1L&lt;span style="color:#719e07">,&lt;/span> message&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;User ID must be greater than 1&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> Long id&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，在很多其他的bean validation的应用场景都是将annotation放到实现类而不是接口上。把annotation放在接口上至少有一个好处是，dubbo的客户端可以共享这个接口的信息，dubbo甚至不需要做远程调用，在本地就可以完成输入校验。&lt;/p>
&lt;p>然后按照dubbo的标准方式在XML配置中打开验证：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">xxx.UserService&amp;#34;&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;userService&amp;#34;&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> validation=&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在dubbo的其他很多远程调用协议中，如果输入验证出错，是直接将&lt;code>RpcException&lt;/code>抛向客户端，而在rest中由于客户端经常是非dubbo，甚至非java的系统，所以不便直接抛出Java异常。因此，目前我们将校验错误以XML的格式返回：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;violationReport&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;constraintViolations&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;path&amp;gt;&lt;/span>getUserArgument0&lt;span style="color:#268bd2">&amp;lt;/path&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;message&amp;gt;&lt;/span>User ID must be greater than 1&lt;span style="color:#268bd2">&amp;lt;/message&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;value&amp;gt;&lt;/span>0&lt;span style="color:#268bd2">&amp;lt;/value&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/constraintViolations&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/violationReport&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>稍后也会支持其他数据格式的返回值。至于如何对验证错误消息作国际化处理，直接参考bean validation的相关文档即可。&lt;/p>
&lt;p>如果你认为默认的校验错误返回格式不符合你的要求，可以如上面章节所述，添加自定义的ExceptionMapper来自由的定制错误返回格式。需要注意的是，这个ExceptionMapper必须用泛型声明来捕获dubbo的RpcException，才能成功覆盖dubbo rest默认的异常处理策略。为了简化操作，其实这里最简单的方式是直接继承dubbo rest的RpcExceptionMapper，并覆盖其中处理校验异常的方法即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">MyValidationExceptionMapper&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> RpcExceptionMapper &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">protected&lt;/span> Response &lt;span style="color:#268bd2">handleConstraintViolationException&lt;/span>&lt;span style="color:#719e07">(&lt;/span>ConstraintViolationException cve&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
ViolationReport report &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ViolationReport&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>ConstraintViolation cv &lt;span style="color:#719e07">:&lt;/span> cve&lt;span style="color:#719e07">.&lt;/span>getConstraintViolations&lt;span style="color:#719e07">())&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
report&lt;span style="color:#719e07">.&lt;/span>addConstraintViolation&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#719e07">new&lt;/span> RestConstraintViolation&lt;span style="color:#719e07">(&lt;/span>
cv&lt;span style="color:#719e07">.&lt;/span>getPropertyPath&lt;span style="color:#719e07">().&lt;/span>toString&lt;span style="color:#719e07">(),&lt;/span>
cv&lt;span style="color:#719e07">.&lt;/span>getMessage&lt;span style="color:#719e07">(),&lt;/span>
cv&lt;span style="color:#719e07">.&lt;/span>getInvalidValue&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;null&amp;#34;&lt;/span> &lt;span style="color:#719e07">:&lt;/span> cv&lt;span style="color:#719e07">.&lt;/span>getInvalidValue&lt;span style="color:#719e07">().&lt;/span>toString&lt;span style="color:#719e07">()));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 采用json输出代替xml输出
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> Response&lt;span style="color:#719e07">.&lt;/span>status&lt;span style="color:#719e07">(&lt;/span>Response&lt;span style="color:#719e07">.&lt;/span>Status&lt;span style="color:#719e07">.&lt;/span>INTERNAL_SERVER_ERROR&lt;span style="color:#719e07">).&lt;/span>entity&lt;span style="color:#719e07">(&lt;/span>report&lt;span style="color:#719e07">).&lt;/span>type&lt;span style="color:#719e07">(&lt;/span>ContentType&lt;span style="color:#719e07">.&lt;/span>APPLICATION_JSON_UTF_8&lt;span style="color:#719e07">).&lt;/span>build&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后将这个ExceptionMapper添加到XML配置中即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;rest&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8888&amp;#34;&lt;/span> extension=&lt;span style="color:#2aa198">&amp;#34;xxx.MyValidationExceptionMapper&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: SPI 自适应拓展</title><link>/zh/docs/v2.7/dev/source/adaptive-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/source/adaptive-extension/</guid><description>
&lt;h2 id="1原理">1.原理&lt;/h2>
&lt;p>在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个示例进行演示。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">WheelMaker&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Wheel &lt;span style="color:#268bd2">makeWheel&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>WheelMaker 接口的自适应实现类如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">AdaptiveWheelMaker&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> WheelMaker &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> Wheel &lt;span style="color:#268bd2">makeWheel&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>url &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 1.从 URL 中获取 WheelMaker 名称
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String wheelMakerName &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Wheel.maker&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>wheelMakerName &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;wheelMakerName == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 2.通过 SPI 加载具体的 WheelMaker
&lt;/span>&lt;span style="color:#586e75">&lt;/span> WheelMaker wheelMaker &lt;span style="color:#719e07">=&lt;/span> ExtensionLoader
&lt;span style="color:#719e07">.&lt;/span>getExtensionLoader&lt;span style="color:#719e07">(&lt;/span>WheelMaker&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">).&lt;/span>getExtension&lt;span style="color:#719e07">(&lt;/span>wheelMakerName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 3.调用目标方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> wheelMaker&lt;span style="color:#719e07">.&lt;/span>makeWheel&lt;span style="color:#719e07">(&lt;/span>url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>AdaptiveWheelMaker 是一个代理类，与传统的代理逻辑不同，AdaptiveWheelMaker 所代理的对象是在 makeWheel 方法中通过 SPI 加载得到的。makeWheel 方法主要做了三件事情：&lt;/p>
&lt;ol>
&lt;li>从 URL 中获取 WheelMaker 名称&lt;/li>
&lt;li>通过 SPI 加载具体的 WheelMaker 实现类&lt;/li>
&lt;li>调用目标方法&lt;/li>
&lt;/ol>
&lt;p>接下来，我们来看看汽车制造厂 CarMaker 接口与其实现类。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">CarMaker&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Car &lt;span style="color:#268bd2">makeCar&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">RaceCarMaker&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> CarMaker &lt;span style="color:#719e07">{&lt;/span>
WheelMaker wheelMaker&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 通过 setter 注入 AdaptiveWheelMaker
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">setWheelMaker&lt;/span>&lt;span style="color:#719e07">(&lt;/span>WheelMaker wheelMaker&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">this&lt;/span>&lt;span style="color:#719e07">.&lt;/span>wheelMaker &lt;span style="color:#719e07">=&lt;/span> wheelMaker&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> Car &lt;span style="color:#268bd2">makeCar&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Wheel wheel &lt;span style="color:#719e07">=&lt;/span> wheelMaker&lt;span style="color:#719e07">.&lt;/span>makeWheel&lt;span style="color:#719e07">(&lt;/span>url&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RaceCar&lt;span style="color:#719e07">(&lt;/span>wheel&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#719e07">...);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>RaceCarMaker 持有一个 WheelMaker 类型的成员变量，在程序启动时，我们可以将 AdaptiveWheelMaker 通过 setter 方法注入到 RaceCarMaker 中。在运行时，假设有这样一个 url 参数传入：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">dubbo://192.168.0.101:20880/XxxService?wheel.maker=MichelinWheelMaker
&lt;/code>&lt;/pre>&lt;/div>&lt;p>RaceCarMaker 的 makeCar 方法将上面的 url 作为参数传给 AdaptiveWheelMaker 的 makeWheel 方法，makeWheel 方法从 url 中提取 wheel.maker 参数，得到 MichelinWheelMaker。之后再通过 SPI 加载配置名为 MichelinWheelMaker 的实现类，得到具体的 WheelMaker 实例。&lt;/p>
&lt;p>上面的示例展示了自适应拓展类的核心实现 &amp;mdash;- 在拓展接口的方法被调用时，通过 SPI 加载具体的拓展实现类，并调用拓展对象的同名方法。接下来，我们深入到源码中，探索自适应拓展类生成的过程。&lt;/p>
&lt;h2 id="2源码分析">2.源码分析&lt;/h2>
&lt;p>在对自适应拓展生成过程进行深入分析之前，我们先来看一下与自适应拓展息息相关的一个注解，即 Adaptive 注解。该注解的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@Documented&lt;/span>
&lt;span style="color:#268bd2">@Retention&lt;/span>&lt;span style="color:#719e07">(&lt;/span>RetentionPolicy&lt;span style="color:#719e07">.&lt;/span>RUNTIME&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">@Target&lt;/span>&lt;span style="color:#719e07">({&lt;/span>ElementType&lt;span style="color:#719e07">.&lt;/span>TYPE&lt;span style="color:#719e07">,&lt;/span> ElementType&lt;span style="color:#719e07">.&lt;/span>METHOD&lt;span style="color:#719e07">})&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">@interface&lt;/span> Adaptive &lt;span style="color:#719e07">{&lt;/span>
String&lt;span style="color:#719e07">[]&lt;/span> &lt;span style="color:#268bd2">value&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">default&lt;/span> &lt;span style="color:#719e07">{};&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的代码中可知，Adaptive 可注解在类或方法上。当 Adaptive 注解在类上时，Dubbo 不会为该类生成代理类。注解在方法（接口方法）上时，Dubbo 则会为该方法生成代理逻辑。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成。Adaptive 注解的地方不同，相应的处理逻辑也是不同的。注解在类上时，处理逻辑比较简单，本文就不分析了。注解在接口方法上时，处理逻辑较为复杂，本章将会重点分析此块逻辑。&lt;/p>
&lt;h3 id="21-获取自适应拓展">2.1 获取自适应拓展&lt;/h3>
&lt;p>getAdaptiveExtension 方法是获取自适应拓展的入口方法，因此下面我们从这个方法进行分析。相关代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">getAdaptiveExtension&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 从缓存中获取自适应拓展
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Object instance &lt;span style="color:#719e07">=&lt;/span> cachedAdaptiveInstance&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span> &lt;span style="color:#586e75">// 缓存未命中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>createAdaptiveInstanceError &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#719e07">(&lt;/span>cachedAdaptiveInstance&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
instance &lt;span style="color:#719e07">=&lt;/span> cachedAdaptiveInstance&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 创建自适应拓展
&lt;/span>&lt;span style="color:#586e75">&lt;/span> instance &lt;span style="color:#719e07">=&lt;/span> createAdaptiveExtension&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 设置自适应拓展到缓存中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> cachedAdaptiveInstance&lt;span style="color:#719e07">.&lt;/span>set&lt;span style="color:#719e07">(&lt;/span>instance&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Throwable t&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
createAdaptiveInstanceError &lt;span style="color:#719e07">=&lt;/span> t&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;fail to create adaptive instance: ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;fail to create adaptive instance: ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">(&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> instance&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>getAdaptiveExtension 方法首先会检查缓存，缓存未命中，则调用 createAdaptiveExtension 方法创建自适应拓展。下面，我们看一下 createAdaptiveExtension 方法的代码。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> T &lt;span style="color:#268bd2">createAdaptiveExtension&lt;/span>&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">try&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取自适应拓展类，并通过反射实例化
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> injectExtension&lt;span style="color:#719e07">((&lt;/span>T&lt;span style="color:#719e07">)&lt;/span> getAdaptiveExtensionClass&lt;span style="color:#719e07">().&lt;/span>newInstance&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">catch&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Exception e&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;Can not create adaptive extension ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>createAdaptiveExtension 方法的代码比较少，但却包含了三个逻辑，分别如下：&lt;/p>
&lt;ol>
&lt;li>调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象&lt;/li>
&lt;li>通过反射进行实例化&lt;/li>
&lt;li>调用 injectExtension 方法向拓展实例中注入依赖&lt;/li>
&lt;/ol>
&lt;p>前两个逻辑比较好理解，第三个逻辑用于向自适应拓展对象中注入依赖。这个逻辑看似多余，但有存在的必要，这里简单说明一下。前面说过，Dubbo 中有两种类型的自适应拓展，一种是手工编码的，一种是自动生成的。手工编码的自适应拓展中可能存在着一些依赖，而自动生成的 Adaptive 拓展则不会依赖其他类。这里调用 injectExtension 方法的目的是为手工编码的自适应拓展注入依赖，这一点需要大家注意一下。关于 injectExtension 方法，前文已经分析过了，这里不再赘述。接下来，分析 getAdaptiveExtensionClass 方法的逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> getAdaptiveExtensionClass&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 通过 SPI 获取所有的拓展类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getExtensionClasses&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 检查缓存，若缓存不为空，则直接返回缓存
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>cachedAdaptiveClass &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> cachedAdaptiveClass&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 创建自适应拓展类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> cachedAdaptiveClass &lt;span style="color:#719e07">=&lt;/span> createAdaptiveExtensionClass&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>getAdaptiveExtensionClass 方法同样包含了三个逻辑，如下：&lt;/p>
&lt;ol>
&lt;li>调用 getExtensionClasses 获取所有的拓展类&lt;/li>
&lt;li>检查缓存，若缓存不为空，则返回缓存&lt;/li>
&lt;li>若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类&lt;/li>
&lt;/ol>
&lt;p>这三个逻辑看起来平淡无奇，似乎没有多讲的必要。但是这些平淡无奇的代码中隐藏了着一些细节，需要说明一下。首先从第一个逻辑说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中，如果某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。相关代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">private&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> createAdaptiveExtensionClass&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 构建自适应拓展代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String code &lt;span style="color:#719e07">=&lt;/span> createAdaptiveExtensionClassCode&lt;span style="color:#719e07">();&lt;/span>
ClassLoader classLoader &lt;span style="color:#719e07">=&lt;/span> findClassLoader&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 获取编译器实现类
&lt;/span>&lt;span style="color:#586e75">&lt;/span> com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>common&lt;span style="color:#719e07">.&lt;/span>compiler&lt;span style="color:#719e07">.&lt;/span>Compiler compiler &lt;span style="color:#719e07">=&lt;/span> ExtensionLoader&lt;span style="color:#719e07">.&lt;/span>getExtensionLoader&lt;span style="color:#719e07">(&lt;/span>com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>common&lt;span style="color:#719e07">.&lt;/span>compiler&lt;span style="color:#719e07">.&lt;/span>Compiler&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">).&lt;/span>getAdaptiveExtension&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 编译代码，生成 Class
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> compiler&lt;span style="color:#719e07">.&lt;/span>compile&lt;span style="color:#719e07">(&lt;/span>code&lt;span style="color:#719e07">,&lt;/span> classLoader&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>createAdaptiveExtensionClass 方法用于生成自适应拓展类，该方法首先会生成自适应拓展类的源码，然后通过 Compiler 实例（Dubbo 默认使用 javassist 作为编译器）编译源码，得到代理类 Class 实例。接下来，我们把重点放在代理类代码生成的逻辑上，其他逻辑大家自行分析。&lt;/p>
&lt;h3 id="22-自适应拓展类代码生成">2.2 自适应拓展类代码生成&lt;/h3>
&lt;p>createAdaptiveExtensionClassCode 方法代码略多，约有两百行代码。因此本节将会对该方法的代码进行拆分分析，以帮助大家更好的理解代码逻辑。&lt;/p>
&lt;h4 id="221-adaptive-注解检测">2.2.1 Adaptive 注解检测&lt;/h4>
&lt;p>在生成代理类源码之前，createAdaptiveExtensionClassCode 方法首先会通过反射检测接口方法是否包含 Adaptive 注解。对于要生成自适应拓展的接口，Dubbo 要求该接口至少有一个方法被 Adaptive 注解修饰。若不满足此条件，就会抛出运行时异常。相关代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#586e75">// 通过反射获取所有的方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span>Method&lt;span style="color:#719e07">[]&lt;/span> methods &lt;span style="color:#719e07">=&lt;/span> type&lt;span style="color:#719e07">.&lt;/span>getMethods&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#dc322f">boolean&lt;/span> hasAdaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 遍历方法列表
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method m &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测方法上是否有 Adaptive 注解
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>m&lt;span style="color:#719e07">.&lt;/span>isAnnotationPresent&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
hasAdaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">break&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>hasAdaptiveAnnotation&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#586e75">// 若所有的方法上均无 Adaptive 注解，则抛出异常
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;No adaptive method on extension ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="222-生成类">2.2.2 生成类&lt;/h4>
&lt;p>通过 Adaptive 注解检测后，即可开始生成代码。代码生成的顺序与 Java 文件内容顺序一致，首先会生成 package 语句，然后生成 import 语句，紧接着生成类名等代码。整个逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#586e75">// 生成 package 代码：package + type 所在包
&lt;/span>&lt;span style="color:#586e75">&lt;/span>codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;package &amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">.&lt;/span>getPackage&lt;span style="color:#719e07">().&lt;/span>getName&lt;span style="color:#719e07">()).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;;&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 生成 import 代码：import + ExtensionLoader 全限定名
&lt;/span>&lt;span style="color:#586e75">&lt;/span>codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nimport &amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>ExtensionLoader&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">()).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;;&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 生成类代码：public class + type简单名称 + $Adaptive + implements + type全限定名 + {
&lt;/span>&lt;span style="color:#586e75">&lt;/span>codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\npublic class &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">.&lt;/span>getSimpleName&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;$Adaptive&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; implements &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">.&lt;/span>getCanonicalName&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; {&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// ${生成方法}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\n}&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里使用 ${&amp;hellip;} 占位符代表其他代码的生成逻辑，该部分逻辑将在随后进行分析。上面代码不是很难理解，下面直接通过一个例子展示该段代码所生成的内容。以 Dubbo 的 Protocol 接口为例，生成的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> com.alibaba.dubbo.rpc&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> com.alibaba.dubbo.common.extension.ExtensionLoader&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Protocol$Adaptive&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>rpc&lt;span style="color:#719e07">.&lt;/span>Protocol &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 省略方法代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="223-生成方法">2.2.3 生成方法&lt;/h4>
&lt;p>一个方法可以被 Adaptive 注解修饰，也可以不被修饰。这里将未被 Adaptive 注解修饰的方法称为“无 Adaptive 注解方法”，下面我们先来看看此种方法的代码生成逻辑是怎样的。&lt;/p>
&lt;h5 id="2231-无-adaptive-注解方法代码生成逻辑">2.2.3.1 无 Adaptive 注解方法代码生成逻辑&lt;/h5>
&lt;p>对于接口方法，我们可以按照需求标注 Adaptive 注解。以 Protocol 接口为例，该接口的 destroy 和 getDefaultPort 未标注 Adaptive 注解，其他方法均标注了 Adaptive 注解。Dubbo 不会为没有标注 Adaptive 注解的方法生成代理逻辑，对于该种类型的方法，仅会生成一句抛出异常的代码。生成逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 如果方法上无 Adaptive 注解，则生成 throw new UnsupportedOperationException(...) 代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 生成的代码格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// throw new UnsupportedOperationException(
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// &amp;#34;method &amp;#34; + 方法签名 + of interface + 全限定接口名 + is not adaptive method!”)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;throw new UnsupportedOperationException(\&amp;#34;method &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">.&lt;/span>toString&lt;span style="color:#719e07">()).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; of interface &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>type&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">()).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; is not adaptive method!\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以 Protocol 接口的 destroy 方法为例，上面代码生成的内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> UnsupportedOperationException&lt;span style="color:#719e07">(&lt;/span>
&lt;span style="color:#2aa198">&amp;#34;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2232-获取-url-数据">2.2.3.2 获取 URL 数据&lt;/h5>
&lt;p>前面说过方法代理逻辑会从 URL 中提取目标拓展的名称，因此代码生成逻辑的一个重要的任务是从方法的参数列表或者其他参数中获取 URL 数据。举例说明一下，我们要为 Protocol 接口的 refer 和 export 方法生成代理逻辑。在运行时，通过反射得到的方法定义大致如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">Invoker &lt;span style="color:#268bd2">refer&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> arg0&lt;span style="color:#719e07">,&lt;/span> URL arg1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException&lt;span style="color:#719e07">;&lt;/span>
Exporter &lt;span style="color:#268bd2">export&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> arg0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException&lt;span style="color:#719e07">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 refer 方法，通过遍历 refer 的参数列表即可获取 URL 数据，这个还比较简单。对于 export 方法，获取 URL 数据则要麻烦一些。export 参数列表中没有 URL 参数，因此需要从 Invoker 参数中获取 URL 数据。获取方式是调用 Invoker 中可返回 URL 的 getter 方法，比如 getUrl。如果 Invoker 中无相关 getter 方法，此时则会抛出异常。整个逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#dc322f">int&lt;/span> urlTypeIndex &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">-&lt;/span>1&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 遍历参数列表，确定 URL 参数位置
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> pts&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> &lt;span style="color:#719e07">++&lt;/span>i&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>pts&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">].&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>URL&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
urlTypeIndex &lt;span style="color:#719e07">=&lt;/span> i&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">break&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// urlTypeIndex != -1，表示参数列表中存在 URL 参数
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>urlTypeIndex &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#719e07">-&lt;/span>1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 为 URL 类型参数生成判空代码，格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// if (arg + urlTypeIndex == null)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// throw new IllegalArgumentException(&amp;#34;url == null&amp;#34;);
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nif (arg%d == null) throw new IllegalArgumentException(\&amp;#34;url == null\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span>
urlTypeIndex&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 为 URL 类型参数生成赋值代码，形如 URL url = arg1
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\n%s url = arg%d;&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> URL&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">(),&lt;/span> urlTypeIndex&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 参数列表中不存在 URL 类型参数
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String attribMethod &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
LBL_PTS:
&lt;span style="color:#586e75">// 遍历方法的参数类型列表
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> pts&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> &lt;span style="color:#719e07">++&lt;/span>i&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取某一类型参数的全部方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Method&lt;span style="color:#719e07">[]&lt;/span> ms &lt;span style="color:#719e07">=&lt;/span> pts&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">].&lt;/span>getMethods&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 遍历方法列表，寻找可返回 URL 的 getter 方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method m &lt;span style="color:#719e07">:&lt;/span> ms&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String name &lt;span style="color:#719e07">=&lt;/span> m&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 1. 方法名以 get 开头，或方法名大于3个字符
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 2. 方法的访问权限为 public
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 3. 非静态方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 4. 方法参数数量为0
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 5. 方法返回值类型为 URL
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">((&lt;/span>name&lt;span style="color:#719e07">.&lt;/span>startsWith&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">||&lt;/span> name&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">&amp;gt;&lt;/span> 3&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> Modifier&lt;span style="color:#719e07">.&lt;/span>isPublic&lt;span style="color:#719e07">(&lt;/span>m&lt;span style="color:#719e07">.&lt;/span>getModifiers&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>Modifier&lt;span style="color:#719e07">.&lt;/span>isStatic&lt;span style="color:#719e07">(&lt;/span>m&lt;span style="color:#719e07">.&lt;/span>getModifiers&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> m&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">().&lt;/span>length &lt;span style="color:#719e07">==&lt;/span> 0
&lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> m&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> URL&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
urlTypeIndex &lt;span style="color:#719e07">=&lt;/span> i&lt;span style="color:#719e07">;&lt;/span>
attribMethod &lt;span style="color:#719e07">=&lt;/span> name&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 结束 for (int i = 0; i &amp;lt; pts.length; ++i) 循环
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">break&lt;/span> LBL_PTS&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>attribMethod &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 如果所有参数中均不包含可返回 URL 的 getter 方法，则抛出异常
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;fail to create adaptive class for interface ...&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 为可返回 URL 的参数生成判空代码，格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// if (arg + urlTypeIndex == null)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// throw new IllegalArgumentException(&amp;#34;参数全限定名 + argument == null&amp;#34;);
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nif (arg%d == null) throw new IllegalArgumentException(\&amp;#34;%s argument == null\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span>
urlTypeIndex&lt;span style="color:#719e07">,&lt;/span> pts&lt;span style="color:#719e07">[&lt;/span>urlTypeIndex&lt;span style="color:#719e07">].&lt;/span>getName&lt;span style="color:#719e07">());&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 为 getter 方法返回的 URL 生成判空代码，格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// if (argN.getter方法名() == null)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// throw new IllegalArgumentException(参数全限定名 + argument getUrl() == null);
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nif (arg%d.%s() == null) throw new IllegalArgumentException(\&amp;#34;%s argument %s() == null\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span>
urlTypeIndex&lt;span style="color:#719e07">,&lt;/span> attribMethod&lt;span style="color:#719e07">,&lt;/span> pts&lt;span style="color:#719e07">[&lt;/span>urlTypeIndex&lt;span style="color:#719e07">].&lt;/span>getName&lt;span style="color:#719e07">(),&lt;/span> attribMethod&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 生成赋值语句，格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// URL全限定名 url = argN.getter方法名()，比如
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// com.alibaba.dubbo.common.URL url = invoker.getUrl();
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;%s url = arg%d.%s();&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> URL&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">(),&lt;/span> urlTypeIndex&lt;span style="color:#719e07">,&lt;/span> attribMethod&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码有点多，需要耐心看一下。这段代码主要目的是为了获取 URL 数据，并为之生成判空和赋值代码。以 Protocol 的 refer 和 export 方法为例，上面的代码为它们生成如下内容（代码已格式化）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">refer:
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>arg1 &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>common&lt;span style="color:#719e07">.&lt;/span>URL url &lt;span style="color:#719e07">=&lt;/span> arg1&lt;span style="color:#719e07">;&lt;/span>
export:
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>arg0 &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;com.alibaba.dubbo.rpc.Invoker argument == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>arg0&lt;span style="color:#719e07">.&lt;/span>getUrl&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>common&lt;span style="color:#719e07">.&lt;/span>URL url &lt;span style="color:#719e07">=&lt;/span> arg0&lt;span style="color:#719e07">.&lt;/span>getUrl&lt;span style="color:#719e07">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2233-获取-adaptive-注解值">2.2.3.3 获取 Adaptive 注解值&lt;/h5>
&lt;p>Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组。若 value 为非空数组，直接获取数组内容即可。若 value 为空数组，则需进行额外处理。处理过程是将类名转换为字符数组，然后遍历字符数组，并将字符放入 StringBuilder 中。若字符为大写字母，则向 StringBuilder 中添加点号，随后将字符变为小写存入 StringBuilder 中。比如 LoadBalance 经过处理后，得到 load.balance。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${获取 URL 数据}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
String&lt;span style="color:#719e07">[]&lt;/span> value &lt;span style="color:#719e07">=&lt;/span> adaptiveAnnotation&lt;span style="color:#719e07">.&lt;/span>value&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// value 为空数组
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">==&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 获取类名，并将类名转换为字符数组
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#dc322f">char&lt;/span>&lt;span style="color:#719e07">[]&lt;/span> charArray &lt;span style="color:#719e07">=&lt;/span> type&lt;span style="color:#719e07">.&lt;/span>getSimpleName&lt;span style="color:#719e07">().&lt;/span>toCharArray&lt;span style="color:#719e07">();&lt;/span>
StringBuilder sb &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>128&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 遍历字节数组
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> charArray&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> i&lt;span style="color:#719e07">++)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 检测当前字符是否为大写字母
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Character&lt;span style="color:#719e07">.&lt;/span>isUpperCase&lt;span style="color:#719e07">(&lt;/span>charArray&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">!=&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 向 sb 中添加点号
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sb&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;.&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 将字符变为小写，并添加到 sb 中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sb&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>Character&lt;span style="color:#719e07">.&lt;/span>toLowerCase&lt;span style="color:#719e07">(&lt;/span>charArray&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]));&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 添加字符到 sb 中
&lt;/span>&lt;span style="color:#586e75">&lt;/span> sb&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>charArray&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
value &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[]{&lt;/span>sb&lt;span style="color:#719e07">.&lt;/span>toString&lt;span style="color:#719e07">()};&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2234-检测-invocation-参数">2.2.3.4 检测 Invocation 参数&lt;/h5>
&lt;p>此段逻辑是检测方法列表中是否存在 Invocation 类型的参数，若存在，则为其生成判空代码和其他一些代码。相应的逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span> &lt;span style="color:#586e75">// 获取参数类型列表
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${获取 URL 数据}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${获取 Adaptive 注解值}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#dc322f">boolean&lt;/span> hasInvocation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 遍历参数类型列表
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> pts&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> &lt;span style="color:#719e07">++&lt;/span>i&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 判断当前参数名称是否等于 com.alibaba.dubbo.rpc.Invocation
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>pts&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">].&lt;/span>getName&lt;span style="color:#719e07">().&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;com.alibaba.dubbo.rpc.Invocation&amp;#34;&lt;/span>&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 为 Invocation 类型参数生成判空代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nif (arg%d == null) throw new IllegalArgumentException(\&amp;#34;invocation == null\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 生成 getMethodName 方法调用代码，格式为：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// String methodName = argN.getMethodName();
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nString methodName = arg%d.getMethodName();&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> i&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 设置 hasInvocation 为 true
&lt;/span>&lt;span style="color:#586e75">&lt;/span> hasInvocation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">break&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2235-生成拓展名获取逻辑">2.2.3.5 生成拓展名获取逻辑&lt;/h5>
&lt;p>本段逻辑用于根据 SPI 和 Adaptive 注解值生成“获取拓展名逻辑”，同时生成逻辑也受 Invocation 类型参数影响，综合因素导致本段逻辑相对复杂。本段逻辑可能会生成但不限于下面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">String extName &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">(&lt;/span>url&lt;span style="color:#719e07">.&lt;/span>getProtocol&lt;span style="color:#719e07">()&lt;/span> &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> &lt;span style="color:#719e07">:&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getProtocol&lt;span style="color:#719e07">());&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">String extName &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getMethodParameter&lt;span style="color:#719e07">(&lt;/span>methodName&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;loadbalance&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;random&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>亦或是&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">String extName &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;transporter&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">));&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本段逻辑复杂之处在于条件分支比较多，大家在阅读源码时需要知道每个条件分支的意义是什么，否则不太容易看懂相关代码。下面开始分析本段逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// $无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${获取 URL 数据}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${获取 Adaptive 注解值}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${检测 Invocation 参数}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// 设置默认拓展名，cachedDefaultName 源于 SPI 注解值，默认情况下，
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// SPI 注解值为空串，此时 cachedDefaultName = null
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String defaultExtName &lt;span style="color:#719e07">=&lt;/span> cachedDefaultName&lt;span style="color:#719e07">;&lt;/span>
String getNameCode &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 遍历 value，这里的 value 是 Adaptive 的注解值，2.2.3.3 节分析过 value 变量的获取过程。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 此处循环目的是生成从 URL 中获取拓展名的代码，生成的代码会赋值给 getNameCode 变量。注意这
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 个循环的遍历顺序是由后向前遍历的。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">-&lt;/span> 1&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;gt;=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> &lt;span style="color:#719e07">--&lt;/span>i&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 当 i 为最后一个元素的坐标时
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">==&lt;/span> value&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">-&lt;/span> 1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 默认拓展名非空
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> defaultExtName&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// protocol 是 url 的一部分，可通过 getProtocol 方法获取，其他的则是从
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// URL 参数中获取。因为获取方式不同，所以这里要判断 value[i] 是否为 protocol
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>&lt;span style="color:#2aa198">&amp;#34;protocol&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]))&lt;/span>
&lt;span style="color:#586e75">// hasInvocation 用于标识方法参数列表中是否有 Invocation 类型参数
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>hasInvocation&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getMethodParameter(methodName, value[i], defaultExtName)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 以 LoadBalance 接口的 select 方法为例，最终生成的代码如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getMethodParameter(methodName, &amp;#34;loadbalance&amp;#34;, &amp;#34;random&amp;#34;)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getMethodParameter(methodName, \&amp;#34;%s\&amp;#34;, \&amp;#34;%s\&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">],&lt;/span> defaultExtName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getParameter(value[i], defaultExtName)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getParameter(\&amp;#34;%s\&amp;#34;, \&amp;#34;%s\&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">],&lt;/span> defaultExtName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;( url.getProtocol() == null ? \&amp;#34;%s\&amp;#34; : url.getProtocol() )&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> defaultExtName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 默认拓展名为空
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>&lt;span style="color:#2aa198">&amp;#34;protocol&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]))&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>hasInvocation&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#586e75">// 生成代码格式同上
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getMethodParameter(methodName, \&amp;#34;%s\&amp;#34;, \&amp;#34;%s\&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">],&lt;/span> defaultExtName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getParameter(value[i])
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getParameter(\&amp;#34;%s\&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成从 url 中获取协议的代码，比如 &amp;#34;dubbo&amp;#34;
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;url.getProtocol()&amp;#34;&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>&lt;span style="color:#2aa198">&amp;#34;protocol&amp;#34;&lt;/span>&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]))&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>hasInvocation&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#586e75">// 生成代码格式同上
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getMethodParameter(methodName, \&amp;#34;%s\&amp;#34;, \&amp;#34;%s\&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">],&lt;/span> defaultExtName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getParameter(value[i], getNameCode)
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 以 Transporter 接口的 connect 方法为例，最终生成的代码如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getParameter(&amp;#34;client&amp;#34;, url.getParameter(&amp;#34;transporter&amp;#34;, &amp;#34;netty&amp;#34;))
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getParameter(\&amp;#34;%s\&amp;#34;, %s)&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> value&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">],&lt;/span> getNameCode&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">else&lt;/span>
&lt;span style="color:#586e75">// 生成的代码功能等价于下面的代码：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getProtocol() == null ? getNameCode : url.getProtocol()
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 以 Protocol 接口的 connect 方法为例，最终生成的代码如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// url.getProtocol() == null ? &amp;#34;dubbo&amp;#34; : url.getProtocol()
&lt;/span>&lt;span style="color:#586e75">&lt;/span> getNameCode &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;url.getProtocol() == null ? (%s) : url.getProtocol()&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> getNameCode&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 生成 extName 赋值代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nString extName = &amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>getNameCode&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;;&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 生成 extName 判空代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nif(extName == null) &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;span style="color:#2aa198">&amp;#34;throw new IllegalStateException(\&amp;#34;Fail to get extension(%s) name from url(\&amp;#34; + url.toString() + \&amp;#34;) use keys(%s)\&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span>
type&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">(),&lt;/span> Arrays&lt;span style="color:#719e07">.&lt;/span>toString&lt;span style="color:#719e07">(&lt;/span>value&lt;span style="color:#719e07">));&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码比较复杂，不是很好理解。对于这段代码，建议大家写点测试用例，对 Protocol、LoadBalance 以及 Transporter 等接口的自适应拓展类代码生成过程进行调试。这里我以 Transporter 接口的自适应拓展类代码生成过程举例说明。首先看一下 Transporter 接口的定义，如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">@SPI&lt;/span>&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Transporter&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// @Adaptive({server, transporter})
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">@Adaptive&lt;/span>&lt;span style="color:#719e07">({&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>SERVER_KEY&lt;span style="color:#719e07">,&lt;/span> Constants&lt;span style="color:#719e07">.&lt;/span>TRANSPORTER_KEY&lt;span style="color:#719e07">})&lt;/span>
Server &lt;span style="color:#268bd2">bind&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">,&lt;/span> ChannelHandler handler&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RemotingException&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// @Adaptive({client, transporter})
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#268bd2">@Adaptive&lt;/span>&lt;span style="color:#719e07">({&lt;/span>Constants&lt;span style="color:#719e07">.&lt;/span>CLIENT_KEY&lt;span style="color:#719e07">,&lt;/span> Constants&lt;span style="color:#719e07">.&lt;/span>TRANSPORTER_KEY&lt;span style="color:#719e07">})&lt;/span>
Client &lt;span style="color:#268bd2">connect&lt;/span>&lt;span style="color:#719e07">(&lt;/span>URL url&lt;span style="color:#719e07">,&lt;/span> ChannelHandler handler&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RemotingException&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面对 connect 方法代理逻辑生成的过程进行分析，此时生成代理逻辑所用到的变量如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">String defaultExtName &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#dc322f">boolean&lt;/span> hasInvocation &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
String getNameCode &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">;&lt;/span>
String&lt;span style="color:#719e07">[]&lt;/span> value &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">[&lt;/span>&lt;span style="color:#2aa198">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;transporter&amp;#34;&lt;/span>&lt;span style="color:#719e07">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面对 value 数组进行遍历，此时 i = 1, value[i] = &amp;ldquo;transporter&amp;rdquo;，生成的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">getNameCode &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;transporter&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，for 循环继续执行，此时 i = 0, value[i] = &amp;ldquo;client&amp;rdquo;，生成的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">getNameCode &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;transporter&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">));&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>for 循环结束运行，现在为 extName 变量生成赋值和判空代码，如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">String extName &lt;span style="color:#719e07">=&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>getParameter&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;transporter&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;netty&amp;#34;&lt;/span>&lt;span style="color:#719e07">));&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>extName &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException&lt;span style="color:#719e07">(&lt;/span>
&lt;span style="color:#2aa198">&amp;#34;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url&lt;span style="color:#719e07">.&lt;/span>toString&lt;span style="color:#719e07">()&lt;/span>
&lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) use keys([client, transporter])&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2236-生成拓展加载与目标方法调用逻辑">2.2.3.6 生成拓展加载与目标方法调用逻辑&lt;/h5>
&lt;p>本段代码逻辑用于根据拓展名加载拓展实例，并调用拓展实例的目标方法。相关逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// $无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${获取 URL 数据}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${获取 Adaptive 注解值}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${检测 Invocation 参数}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${生成拓展名获取逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// 生成拓展获取代码，格式如下：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// type全限定名 extension = (type全限定名)ExtensionLoader全限定名
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// .getExtensionLoader(type全限定名.class).getExtension(extName);
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// Tips: 格式化字符串中的 %&amp;lt;s 表示使用前一个转换符所描述的参数，即 type 全限定名
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\n%s extension = (%&amp;lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span>
type&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">(),&lt;/span> ExtensionLoader&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">.&lt;/span>getSimpleName&lt;span style="color:#719e07">(),&lt;/span> type&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">());&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 如果方法返回值类型非 void，则生成 return 语句。
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(!&lt;/span>rt&lt;span style="color:#719e07">.&lt;/span>equals&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">void&lt;/span>&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">))&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\nreturn &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 生成目标方法调用逻辑，格式为：
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// extension.方法名(arg0, arg2, ..., argN);
&lt;/span>&lt;span style="color:#586e75">&lt;/span> s &lt;span style="color:#719e07">=&lt;/span> String&lt;span style="color:#719e07">.&lt;/span>format&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;extension.%s(&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">());&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>s&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> pts&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> i&lt;span style="color:#719e07">++)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">!=&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;arg&amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>i&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
code&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;);&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// 省略无关逻辑
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以 Protocol 接口举例说明，上面代码生成的内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>rpc&lt;span style="color:#719e07">.&lt;/span>Protocol extension &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">(&lt;/span>com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>rpc&lt;span style="color:#719e07">.&lt;/span>Protocol&lt;span style="color:#719e07">)&lt;/span> ExtensionLoader
&lt;span style="color:#719e07">.&lt;/span>getExtensionLoader&lt;span style="color:#719e07">(&lt;/span>com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>rpc&lt;span style="color:#719e07">.&lt;/span>Protocol&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">).&lt;/span>getExtension&lt;span style="color:#719e07">(&lt;/span>extName&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> extension&lt;span style="color:#719e07">.&lt;/span>refer&lt;span style="color:#719e07">(&lt;/span>arg0&lt;span style="color:#719e07">,&lt;/span> arg1&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2237-生成完整的方法">2.2.3.7 生成完整的方法&lt;/h5>
&lt;p>本节进行代码生成的收尾工作，主要用于生成方法定义的代码。相关逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>Method method &lt;span style="color:#719e07">:&lt;/span> methods&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> rt &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getReturnType&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> pts &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getParameterTypes&lt;span style="color:#719e07">();&lt;/span>
Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> ets &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getExceptionTypes&lt;span style="color:#719e07">();&lt;/span>
Adaptive adaptiveAnnotation &lt;span style="color:#719e07">=&lt;/span> method&lt;span style="color:#719e07">.&lt;/span>getAnnotation&lt;span style="color:#719e07">(&lt;/span>Adaptive&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
StringBuilder code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder&lt;span style="color:#719e07">(&lt;/span>512&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>adaptiveAnnotation &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// $无 Adaptive 注解方法代码生成逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// ${获取 URL 数据}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${获取 Adaptive 注解值}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${检测 Invocation 参数}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${生成拓展名获取逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// ${生成拓展加载与目标方法调用逻辑}
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#586e75">// public + 返回值全限定名 + 方法名 + (
&lt;/span>&lt;span style="color:#586e75">&lt;/span>codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\npublic &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>rt&lt;span style="color:#719e07">.&lt;/span>getCanonicalName&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">.&lt;/span>getName&lt;span style="color:#719e07">())&lt;/span>
&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;(&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 添加参数列表代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> pts&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> i&lt;span style="color:#719e07">++)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>pts&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">].&lt;/span>getCanonicalName&lt;span style="color:#719e07">());&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;arg&amp;#34;&lt;/span>&lt;span style="color:#719e07">).&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>i&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;)&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 添加异常抛出代码
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>ets&lt;span style="color:#719e07">.&lt;/span>length &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; throws &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0&lt;span style="color:#719e07">;&lt;/span> i &lt;span style="color:#719e07">&amp;lt;&lt;/span> ets&lt;span style="color:#719e07">.&lt;/span>length&lt;span style="color:#719e07">;&lt;/span> i&lt;span style="color:#719e07">++)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">(&lt;/span>i &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>ets&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">].&lt;/span>getCanonicalName&lt;span style="color:#719e07">());&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34; {&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>code&lt;span style="color:#719e07">.&lt;/span>toString&lt;span style="color:#719e07">());&lt;/span>
codeBuilder&lt;span style="color:#719e07">.&lt;/span>append&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;\n}&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以 Protocol 的 refer 方法为例，上面代码生成的内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#268bd2">public&lt;/span> com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>rpc&lt;span style="color:#719e07">.&lt;/span>Invoker &lt;span style="color:#268bd2">refer&lt;/span>&lt;span style="color:#719e07">(&lt;/span>java&lt;span style="color:#719e07">.&lt;/span>lang&lt;span style="color:#719e07">.&lt;/span>Class arg0&lt;span style="color:#719e07">,&lt;/span> com&lt;span style="color:#719e07">.&lt;/span>alibaba&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>common&lt;span style="color:#719e07">.&lt;/span>URL arg1&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// 方法体
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3总结">3.总结&lt;/h2>
&lt;p>到此，关于自适应拓展的原理，实现就分析完了。总的来说自适应拓展整个逻辑还是很复杂的，并不是很容易弄懂。因此，大家在阅读该部分源码时，耐心一些。同时多进行调试，也可以通过生成好的代码思考代码的生成逻辑。好了，本篇文章就分析到这里。&lt;/p></description></item><item><title>Docs: 动态配置中心</title><link>/zh/docs/v2.7/user/configuration/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/configuration/config-center/</guid><description>
&lt;p>配置中心（v2.7.0）在 Dubbo 中承担两个职责：&lt;/p>
&lt;ol>
&lt;li>外部化配置。启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。&lt;/li>
&lt;li>服务治理。服务治理规则的存储与通知。&lt;/li>
&lt;/ol>
&lt;p>启用动态配置，以 Zookeeper 为例，可查看 &lt;a href="../../references/xml/dubbo-config-center">动态配置配置项详解&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:config-center&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">dubbo.config-center.address=zookeeper://127.0.0.1:2181
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">ConfigCenterConfig configCenter &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConfigCenterConfig&lt;span style="color:#719e07">();&lt;/span>
configCenter&lt;span style="color:#719e07">.&lt;/span>setAddress&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>为了兼容 2.6.x 版本配置，在使用 Zookeeper 作为注册中心，且没有显示配置配置中心的情况下，Dubbo 框架会默认将此 Zookeeper 用作配置中心，但将只作服务治理用途。&lt;/p>
&lt;/blockquote>
&lt;h2 id="外部化配置">外部化配置&lt;/h2>
&lt;p>外部化配置目的之一是实现配置的集中式管理，这部分业界已经有很多成熟的专业配置系统如 Apollo, Nacos 等，Dubbo 所做的主要是保证能配合这些系统正常工作。&lt;/p>
&lt;p>外部化配置和其他本地配置在内容和格式上并无区别，可以简单理解为 &lt;code>dubbo.properties&lt;/code> 的外部化存储，配置中心更适合将一些公共配置如注册中心、元数据中心配置等抽取以便做集中管理。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># 将注册中心地址、元数据中心地址等配置集中管理，可以做到统一环境、减少开发侧感知。
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.simplified=true
dubbo.metadata-report.address=zookeeper://127.0.0.1:2181
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.application.qos.port=33333
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>优先级&lt;/p>
&lt;p>外部化配置默认较本地配置有更高的优先级，因此这里配置的内容会覆盖本地配置值，关于 &lt;a href="../configuration-load-process">各配置形式间的覆盖关系&lt;/a> 有单独一章说明，你也可通过以下选项调整配置中心的优先级：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">-Ddubbo.config-center.highest-priority=false
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>作用域&lt;/p>
&lt;p>外部化配置有全局和应用两个级别，全局配置是所有应用共享的，应用级配置是由每个应用自己维护且只对自身可见的。当前已支持的扩展实现有Zookeeper、Apollo。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="zookeeper">Zookeeper&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:config-center&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认所有的配置都存储在 &lt;code>/dubbo/config&lt;/code> 节点，具体节点结构图如下：&lt;/p>
&lt;p>&lt;img src="/imgs/user/zk-configcenter.jpg" alt="zk-configcenter.jpg">&lt;/p>
&lt;ul>
&lt;li>namespace，用于不同配置的环境隔离。&lt;/li>
&lt;li>config，Dubbo约定的固定节点，不可更改，所有配置和服务治理规则都存储在此节点下。&lt;/li>
&lt;li>dubbo/application，分别用来隔离全局配置、应用级别配置：dubbo是默认group值，application对应应用名&lt;/li>
&lt;li>dubbo.properties，此节点的node value存储具体配置内容&lt;/li>
&lt;/ul>
&lt;h4 id="apollo">Apollo&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:config-center&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;apollo&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Apollo中的一个核心概念是命名空间 - namespace（和上面zookeeper的namespace概念不同），在这里全局和应用级别配置就是通过命名空间来区分的。&lt;/p>
&lt;p>默认情况下，Dubbo会从名叫&lt;code>dubbo&lt;/code>（由于 Apollo 不支持特殊后缀 &lt;code>.properties&lt;/code> ）的命名空间中读取全局配置（&lt;code>&amp;lt;dubbo:config-center namespace=&amp;quot;your namespace&amp;quot;&amp;gt;&lt;/code>）&lt;/p>
&lt;p>&lt;img src="/imgs/user/apollo-configcenter-dubbo.png" alt="apollo-configcenter-dubbo.png">&lt;/p>
&lt;p>由于 Apollo 也默认将会在 &lt;code>dubbo&lt;/code> namespace 中存储服务治理规则（如路由规则），建议通过单独配置 &lt;code>group&lt;/code> 将服务治理和配置文件托管分离开，以 XML 配置方式为例：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo&lt;/span> namespace=&lt;span style="color:#2aa198">&amp;#34;governance&amp;#34;&lt;/span> group =&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里，服务治理规则将存储在 governance namespace，而配置文件将存储在 dubbo namespace，如下图所示：
&lt;img src="/imgs/user/apollo-configcenter-governance-dubbo.png" alt="apollo-configcenter-governance-dubbo.png">&lt;/p>
&lt;blockquote>
&lt;p>关于文件配置托管，相当于是把 &lt;code>dubbo.properties&lt;/code> 配置文件的内容存储在了 Apollo 中，应用通过关联共享的 &lt;code>dubbo&lt;/code> namespace 继承公共配置,
应用也可以按照 Apollo 的做法来覆盖个别配置项。&lt;/p>
&lt;/blockquote>
&lt;h4 id="自己加载外部化配置">自己加载外部化配置&lt;/h4>
&lt;p>所谓 Dubbo 对配置中心的支持，本质上就是把 &lt;code>.properties&lt;/code> 从远程拉取到本地，然后和本地的配置做一次融合。理论上只要 Dubbo 框架能拿到需要的配置就可以正常的启动，它并不关心这些配置是自己加载到的还是应用直接塞给它的，所以Dubbo还提供了以下API，让用户将自己组织好的配置塞给 Dubbo 框架（配置加载的过程是用户要完成的），这样 Dubbo 框架就不再直接和 Apollo 或 Zookeeper 做读取配置交互。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#586e75">// 应用自行加载配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">,&lt;/span> String&lt;span style="color:#719e07">&amp;gt;&lt;/span> dubboConfigurations &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;();&lt;/span>
dubboConfigurations&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;dubbo.registry.address&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
dubboConfigurations&lt;span style="color:#719e07">.&lt;/span>put&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;dubbo.registry.simplified&amp;#34;&lt;/span>&lt;span style="color:#719e07">,&lt;/span> &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">//将组织好的配置塞给Dubbo框架
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ConfigCenterConfig configCenter &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConfigCenterConfig&lt;span style="color:#719e07">();&lt;/span>
configCenter&lt;span style="color:#719e07">.&lt;/span>setExternalConfig&lt;span style="color:#719e07">(&lt;/span>dubboConfigurations&lt;span style="color:#719e07">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="服务治理">服务治理&lt;/h2>
&lt;h4 id="zookeeper-1">Zookeeper&lt;/h4>
&lt;p>默认节点结构：&lt;/p>
&lt;p>&lt;img src="/imgs/user/zk-configcenter-governance.jpg" alt="zk-configcenter-governance">&lt;/p>
&lt;ul>
&lt;li>namespace，用于不同配置的环境隔离。&lt;/li>
&lt;li>config，Dubbo 约定的固定节点，不可更改，所有配置和服务治理规则都存储在此节点下。&lt;/li>
&lt;li>dubbo，所有服务治理规则都是全局性的，dubbo 为默认节点&lt;/li>
&lt;li>configurators/tag-router/condition-router，不同的服务治理规则类型，node value 存储具体规则内容&lt;/li>
&lt;/ul>
&lt;h4 id="apollo-1">Apollo&lt;/h4>
&lt;p>所有的服务治理规则都是全局性的，默认从公共命名空间 &lt;code>dubbo&lt;/code> 读取和订阅：&lt;/p>
&lt;p>&lt;img src="/imgs/user/apollo-configcenter-governance.jpg" alt="apollo-configcenter-governance.jpg">&lt;/p>
&lt;p>不同的规则以不同的 key 后缀区分：&lt;/p>
&lt;ul>
&lt;li>configurators，&lt;a href="../../examples/config-rule">覆盖规则&lt;/a>&lt;/li>
&lt;li>tag-router，&lt;a href="../../examples/routing-rule">标签路由&lt;/a>&lt;/li>
&lt;li>condition-router，&lt;a href="../../examples/routing-rule">条件路由&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: 如何准备 Apache Release</title><link>/zh/docs/contribution-guidelines/committer/release-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/contribution-guidelines/committer/release-guide_dev/</guid><description>
&lt;h2 id="理解-apache-发布的内容和流程">理解 Apache 发布的内容和流程&lt;/h2>
&lt;p>总的来说，Source Release 是 Apache 关注的重点，也是发布的必须内容；而 Binary Release 是可选项，Dubbo 可以选择是否发布二进制包到 Apache 仓库或者发布到 Maven 中央仓库。&lt;/p>
&lt;p>请参考以下链接，找到更多关于 ASF 的发布指南:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.apache.org/dev/release-publishing">Apache Release Guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.apache.org/dev/release.html">Apache Release Policy&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.apache.org/dev/publishing-maven-artifacts.html">Maven Release Info&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="本地构建环境准备">本地构建环境准备&lt;/h2>
&lt;p>主要包括签名工具、Maven 仓库认证相关准备&lt;/p>
&lt;h3 id="安装gpg">安装GPG&lt;/h3>
&lt;p>详细文档请参见&lt;a href="https://www.gnupg.org/download/index.html">这里&lt;/a>, Mac OS 下配置如下&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ brew install gpg
$ gpg --version &lt;span style="color:#586e75">#检查版本，应该为2.x&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="用gpg生成key">用gpg生成key&lt;/h3>
&lt;p>根据提示，生成 key&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ gpg --full-gen-key
gpg &lt;span style="color:#719e07">(&lt;/span>GnuPG&lt;span style="color:#719e07">)&lt;/span> 2.0.12; Copyright &lt;span style="color:#719e07">(&lt;/span>C&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#2aa198">2009&lt;/span> Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Please &lt;span style="color:#719e07">select&lt;/span> what kind of key you want:
&lt;span style="color:#719e07">(&lt;/span>1&lt;span style="color:#719e07">)&lt;/span> RSA and RSA &lt;span style="color:#719e07">(&lt;/span>default&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">(&lt;/span>2&lt;span style="color:#719e07">)&lt;/span> DSA and Elgamal
&lt;span style="color:#719e07">(&lt;/span>3&lt;span style="color:#719e07">)&lt;/span> DSA &lt;span style="color:#719e07">(&lt;/span>sign only&lt;span style="color:#719e07">)&lt;/span>
&lt;span style="color:#719e07">(&lt;/span>4&lt;span style="color:#719e07">)&lt;/span> RSA &lt;span style="color:#719e07">(&lt;/span>sign only&lt;span style="color:#719e07">)&lt;/span>
Your selection? &lt;span style="color:#2aa198">1&lt;/span>
RSA keys may be between &lt;span style="color:#2aa198">1024&lt;/span> and &lt;span style="color:#2aa198">4096&lt;/span> bits long.
What keysize &lt;span style="color:#719e07">do&lt;/span> you want? &lt;span style="color:#719e07">(&lt;/span>2048&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#2aa198">4096&lt;/span>
Requested keysize is &lt;span style="color:#2aa198">4096&lt;/span> bits
Please specify how long the key should be valid.
&lt;span style="color:#268bd2">0&lt;/span> &lt;span style="color:#719e07">=&lt;/span> key does not expire
&amp;lt;n&amp;gt; &lt;span style="color:#719e07">=&lt;/span> key expires in n days
&amp;lt;n&amp;gt;w &lt;span style="color:#719e07">=&lt;/span> key expires in n weeks
&amp;lt;n&amp;gt;m &lt;span style="color:#719e07">=&lt;/span> key expires in n months
&amp;lt;n&amp;gt;y &lt;span style="color:#719e07">=&lt;/span> key expires in n years
Key is valid &lt;span style="color:#719e07">for&lt;/span>? &lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">)&lt;/span>
Key does not expire at all
Is this correct? &lt;span style="color:#719e07">(&lt;/span>y/N&lt;span style="color:#719e07">)&lt;/span> y
GnuPG needs to construct a user ID to identify your key.
Real name: Robert Burrell Donkin
Email address: rdonkin@apache.org
Comment: CODE SIGNING KEY
You selected this USER-ID:
&lt;span style="color:#2aa198">&amp;#34;Robert Burrell Donkin (CODE SIGNING KEY) &amp;lt;rdonkin@apache.org&amp;gt;&amp;#34;&lt;/span>
Change &lt;span style="color:#719e07">(&lt;/span>N&lt;span style="color:#719e07">)&lt;/span>ame, &lt;span style="color:#719e07">(&lt;/span>C&lt;span style="color:#719e07">)&lt;/span>omment, &lt;span style="color:#719e07">(&lt;/span>E&lt;span style="color:#719e07">)&lt;/span>mail or &lt;span style="color:#719e07">(&lt;/span>O&lt;span style="color:#719e07">)&lt;/span>kay/&lt;span style="color:#719e07">(&lt;/span>Q&lt;span style="color:#719e07">)&lt;/span>uit? O
You need a Passphrase to protect your secret key. &lt;span style="color:#586e75"># 填入密码，以后打包过程中会经常用到&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看-key-id">查看 key id&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ gpg --list-keys
pub rsa4096/28681CB1 2018-04-26 &lt;span style="color:#586e75"># 28681CB1就是key id&lt;/span>
uid &lt;span style="color:#719e07">[&lt;/span>ultimate&lt;span style="color:#719e07">]&lt;/span> liujun &lt;span style="color:#719e07">(&lt;/span>apache-dubbo&lt;span style="color:#719e07">)&lt;/span> &amp;lt;liujun@apache.org&amp;gt;
sub rsa4096/D3D6984B 2018-04-26
&lt;span style="color:#586e75"># 通过key id发送public key到keyserver&lt;/span>
$ gpg --keyserver pgpkeys.mit.edu --send-key 28681CB1
&lt;span style="color:#586e75"># 其中，pgpkeys.mit.edu为随意挑选的keyserver，keyserver列表为：https://sks-keyservers.net/status/，为相互之间是自动同步的，选任意一个都可以。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果有多个 public key，设置默认 key。修改&lt;code>~/.gnupg/gpg.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#586e75"># If you have more than 1 secret key in your keyring, you may want to&lt;/span>
&lt;span style="color:#586e75"># uncomment the following option and set your preferred keyid.&lt;/span>
default-key 28681CB1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果有多个 public key, 也可以删除无用的 key：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#586e75">### 先删除私钥，再删除公钥&lt;/span>
$ gpg --yes --delete-secret-keys shenglicao2@gmail.com &lt;span style="color:#586e75">###老的私钥，指明邮箱即可&lt;/span>
$ gpg --delete-keys 1808C6444C781C0AEA0AAD4C4D6A8007D20DB8A4
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>PS: 最新版本经过实测，本地没有gpg.conf这个文件，因此如果在执行过程中遇到签名失败，可以参考这个文章：https://blog.csdn.net/wenbo20182/article/details/72850810 或 https://d.sb/2016/11/gpg-inappropriate-ioctl-for-device-errors&lt;/p>
&lt;/blockquote>
&lt;p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。
通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#586e75"># fingerprint参数生成公钥指纹：&lt;/span>
$ gpg --fingerprint liujun
pub rsa4096 2019-10-17 &lt;span style="color:#719e07">[&lt;/span>SC&lt;span style="color:#719e07">]&lt;/span>
&lt;span style="color:#2aa198">1376&lt;/span> A2FF 67E4 C477 &lt;span style="color:#2aa198">5739&lt;/span> 09BD 7DB6 &lt;span style="color:#2aa198">8550&lt;/span> D366 E4C0
uid &lt;span style="color:#719e07">[&lt;/span>ultimate&lt;span style="color:#719e07">]&lt;/span> liujun &lt;span style="color:#719e07">(&lt;/span>CODE SIGNING KEY&lt;span style="color:#719e07">)&lt;/span> &amp;lt;liujun@apache.org&amp;gt;
sub rsa4096 2019-10-17 &lt;span style="color:#719e07">[&lt;/span>E&lt;span style="color:#719e07">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>登录 &lt;a href="https://id.apache.org">https://id.apache.org&lt;/a>, 将上面的 fingerprint （即 1376 A2FF 67E4 C477 5739 09BD 7DB6 8550 D366 E4C0）
粘贴到自己的用户信息中 OpenPGP Public Key Primary Fingerprint&lt;/p>
&lt;h3 id="设置-apache-中央仓库">设置 Apache 中央仓库&lt;/h3>
&lt;p>Dubbo 项目的父 pom 为 Apache pom(2.7.0 以上版本需要，2.6.x 发布版本不需要此操作)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;parent&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>org.apache&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>apache&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>19&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加以下内容到 .m2/settings.xml
所有密码请使用 &lt;a href="http://maven.apache.org/guides/mini/guide-encryption.html">maven-encryption-plugin&lt;/a>加密后再填入&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;settings&amp;gt;&lt;/span>
...
&lt;span style="color:#268bd2">&amp;lt;servers&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- To publish a snapshot of some part of Maven --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;server&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;id&amp;gt;&lt;/span>apache.snapshots.https&lt;span style="color:#268bd2">&amp;lt;/id&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;username&amp;gt;&lt;/span> &lt;span style="color:#586e75">&amp;lt;!-- YOUR APACHE LDAP USERNAME --&amp;gt;&lt;/span> &lt;span style="color:#268bd2">&amp;lt;/username&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;password&amp;gt;&lt;/span> &lt;span style="color:#586e75">&amp;lt;!-- YOUR APACHE LDAP PASSWORD (encrypted) --&amp;gt;&lt;/span> &lt;span style="color:#268bd2">&amp;lt;/password&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/server&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- To stage a release of some part of Maven --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;server&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;id&amp;gt;&lt;/span>apache.releases.https&lt;span style="color:#268bd2">&amp;lt;/id&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;username&amp;gt;&lt;/span> &lt;span style="color:#586e75">&amp;lt;!-- YOUR APACHE LDAP USERNAME --&amp;gt;&lt;/span> &lt;span style="color:#268bd2">&amp;lt;/username&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;password&amp;gt;&lt;/span> &lt;span style="color:#586e75">&amp;lt;!-- YOUR APACHE LDAP PASSWORD (encrypted) --&amp;gt;&lt;/span> &lt;span style="color:#268bd2">&amp;lt;/password&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/server&amp;gt;&lt;/span>
...
&lt;span style="color:#586e75">&amp;lt;!-- gpg passphrase used when generate key --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;server&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;id&amp;gt;&lt;/span>gpg.passphrase&lt;span style="color:#268bd2">&amp;lt;/id&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;passphrase&amp;gt;&lt;/span>&lt;span style="color:#586e75">&amp;lt;!-- yourKeyPassword --&amp;gt;&lt;/span>&lt;span style="color:#268bd2">&amp;lt;/passphrase&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/server&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servers&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/settings&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打包上传">打包&amp;amp;上传&lt;/h2>
&lt;h3 id="准备分支">准备分支&lt;/h3>
&lt;p>从主干分支拉取新分支作为发布分支，如现在要发布$&lt;code>{release_version}&lt;/code>版本，则从2.6.x拉出新分支&lt;code>${release_version}-release&lt;/code>，此后&lt;code>${release_version}&lt;/code> Release Candidates涉及的修改及打标签等都在&lt;code>${release_version}-release&lt;/code>分支进行，最终发布完成后合入主干分支。&lt;/p>
&lt;h3 id="编译打包">编译打包&lt;/h3>
&lt;p>首先，在&lt;code>${release_version}-release&lt;/code>分支验证maven组件打包、source源码打包、签名等是否都正常工作。&lt;strong>2.6.x记得要使用1.6进行编译打包&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mvn clean install -Prelease
$ mvn deploy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述命令将snapshot包推送到maven中央仓库&lt;/p>
&lt;h3 id="用maven-release-plugin发布-废弃参考后一步">&lt;del>用maven-release-plugin发布&lt;/del> (&lt;code>废弃&lt;/code>，参考后一步)&lt;/h3>
&lt;p>&lt;del>先用dryRun验证是否ok&lt;/del>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mvn release:prepare -Prelease -Darguments&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;-DskipTests&amp;#34;&lt;/span> -DautoVersionSubmodules&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">true&lt;/span> -Dusername&lt;span style="color:#719e07">=&lt;/span>YOUR GITHUB ID-DdryRun&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;del>验证通过后，执行release:prepare&lt;/del>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mvn release:clean
$ mvn release:prepare -Prelease -Darguments&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;-DskipTests&amp;#34;&lt;/span> -DautoVersionSubmodules&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">true&lt;/span> -Dusername&lt;span style="color:#719e07">=&lt;/span>YOUR GITHUB ID -DpushChanges&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>执行release插件时，如果指定了&lt;code>-DpushChanges=true&lt;/code>, 插件会自动提交到远端的GitHub仓库中，此时就需要输入GitHub的密码，注意不是输入web页面的登录密码，而是一个&lt;code>Personal access tokens&lt;/code>，获取方式详见&lt;a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line">这里&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这里有一点要注意的是tag， 在执行过程中，需要选择发布的artifactId, 下一个版本artifactId以及发布版本的tag, tag默认的是dubbo-parent-xxxx，需要改成dubbo-xxxx&lt;/p>
&lt;/blockquote>
&lt;p>执行完上述步骤后，你会发现：&lt;/p>
&lt;ol>
&lt;li>&lt;code>source-release.zip&lt;/code> 和 &lt;code>bin-release.zip&lt;/code>包已经生成在&lt;code>dubbo-distribution&lt;/code>目录下，请解压并检查文件是否完整&lt;/li>
&lt;li>本地已经打出相应的tag，同时新增一个commit，名叫&lt;code>[maven-release-plugin] prepare release dubbo-x.x.x&lt;/code>&lt;/li>
&lt;li>分支版本自动升级为&lt;code>${release_version+1}-SNAPSHOT&lt;/code>，同时新增一个commit，名叫&lt;code>[[maven-release-plugin] prepare for next development iteration&lt;/code>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果指定了&lt;code>-DpushChanges=true&lt;/code>, 则本地提交会自动推送到远端的GitHub仓库。根据经验，建议不要指定为true，请设置为false，待本地检查通过之后再手动提交&lt;/p>
&lt;/blockquote>
&lt;p>&lt;del>执行release:perform，做staging发布&lt;/del>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mvn -Prelease release:perform -Darguments&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;-DskipTests&amp;#34;&lt;/span> -DautoVersionSubmodules&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">true&lt;/span> -Dusername&lt;span style="color:#719e07">=&lt;/span>YOUR GITHUB ID
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时插件会自动下载远端的tag对应的源码，编译后，将所有Artifacts发布到配置的远程&lt;a href="http://repository.apache.org">maven仓库&lt;/a>，处于staging状态。&lt;/p>
&lt;h3 id="使用mvn-deploy进行deploy">使用mvn deploy进行deploy&lt;/h3>
&lt;blockquote>
&lt;p>要求：maven 3.5+&lt;/p>
&lt;/blockquote>
&lt;p>修改pom文件中的版本号，从2.7.x-SNAPSHOT改为2.7.x， 目前有3个地方需要修改。建议全文搜索。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mvn clean install -Prelease
$ mvn deploy -Prelease -DskipTests
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有被deploy到远程&lt;a href="http://repository.apache.org">maven仓库&lt;/a>的Artifacts都会处于staging状态&lt;/p>
&lt;h4 id="注意点">注意点&lt;/h4>
&lt;ul>
&lt;li>在deploy执行过程中，有可能因为网络等原因被中断，如果是这样，可以重新开始执行。&lt;/li>
&lt;li>deploy执行到maven仓库的时候，请确认下包的总量是否正确。多次出现了包丢失的情况，特别是dubbo-parent包。&lt;/li>
&lt;/ul>
&lt;h2 id="准备apache发布">准备Apache发布&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>准备svn本机环境（Apache使用svn托管项目的发布内容）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将dubbo checkout到本地目录&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ svn checkout https://dist.apache.org/repos/dist/dev/dubbo
&lt;span style="color:#586e75"># 假定本地目录为 ~/apache/dubbo&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>当前发布版本为${release_version}，新建目录&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ &lt;span style="color:#b58900">cd&lt;/span> ~/apache/dubbo &lt;span style="color:#586e75"># dubbo svn根目录&lt;/span>
$ mkdir &lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>添加public key到&lt;a href="https://dist.apache.org/repos/dist/dev/dubbo/KEYS">KEYS&lt;/a>文件并提交到SVN仓库（第一次做发布的人需要做这个操作，具体操作参考KEYS文件里的说明）。KEYS主要是让参与投票的人在本地导入，用来校验sign的正确性&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ &lt;span style="color:#719e07">(&lt;/span>gpg --list-sigs &amp;lt;your name&amp;gt; &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> gpg --armor --export &amp;lt;your name&amp;gt;&lt;span style="color:#719e07">)&lt;/span> &amp;gt;&amp;gt; KEYS
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>拷贝&lt;code>distribution/target&lt;/code>下的source相关的包到svn本地仓库&lt;code>dubbo/${release_version}&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>生成sha512签名&lt;/p>
&lt;p>针对&lt;code>source-release.zip&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ shasum -a &lt;span style="color:#2aa198">512&lt;/span> apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-source-release.zip &amp;gt;&amp;gt; apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-source-release.zip.sha512
&lt;/code>&lt;/pre>&lt;/div>&lt;p>针对&lt;code>bin-release.zip&lt;/code>，需要增加&lt;code>-b&lt;/code>参数，表明是一个二进制文件&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ shasum -b -a &lt;span style="color:#2aa198">512&lt;/span> apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-bin-release.zip &amp;gt;&amp;gt; apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-bin-release.zip.sha512
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>如果有binary release要同时发布&lt;/p>
&lt;p>在&lt;code>distribution/target&lt;/code>目录下，拷贝&lt;code>bin-release.zip&lt;/code>以及&lt;code>bin-release.zip.asc&lt;/code>到svn本地仓库&lt;code>dubbo/${release_version}&lt;/code>，参考第6步，生成sha512签名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提交到Apache svn&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ svn status
$ svn commit -m &lt;span style="color:#2aa198">&amp;#39;prepare for ${release_version} RC1&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>关闭Maven的staging仓库&lt;/p>
&lt;p>此步骤为发布2.7.0及以上版本必须要的步骤。在此之前请先确保所有的artifact都是ok的。登录http://repository.apache.org，点击左侧的&lt;code>Staging repositories&lt;/code>，然后搜索Dubbo关键字，会出现一系列的仓库，选择你最近上传的仓库，然后点击上方的Close按钮，这个过程会进行一系列检查，检查通过以后，在下方的Summary标签页上出现一个连接，请保存好这个链接，需要放在接下来的投票邮件当中。链接应该是类似这样的: &lt;a href="https://repository.apache.org/content/repositories/orgapachedubbo-1015">https://repository.apache.org/content/repositories/orgapachedubbo-1015&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>请注意点击Close可能会出现失败，通常是网络原因，只要重试几次就可以了。可以点击Summary旁边的Activity标签来确认。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h2 id="验证release-candidates">验证Release Candidates&lt;/h2>
&lt;p>详细的检查列表请参考官方的&lt;a href="https://wiki.apache.org/incubator/IncubatorReleaseChecklist">check list&lt;/a>&lt;/p>
&lt;p>首先，从一下地址下载要发布的Release Candidate到本地环境：&lt;/p>
&lt;pre>
https://dist.apache.org/repos/dist/dev/dubbo/${release_version}/
&lt;/pre>
&lt;p>然后，开始验证环节，验证包含但不限于以下内容和形式&lt;/p>
&lt;h3 id="检查签名和hash等信息">检查签名和hash等信息&lt;/h3>
&lt;h4 id="检查sha512哈希">检查sha512哈希&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ shasum -c apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-source-release.zip.sha512
$ shasum -c apache-dubbo-&lt;span style="color:#2aa198">${&lt;/span>&lt;span style="color:#268bd2">release_version&lt;/span>&lt;span style="color:#2aa198">}&lt;/span>-bin-release.zip.sha512
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="检查gpg签名">检查gpg签名&lt;/h4>
&lt;p>如果是第一次检查，需要首先导入公钥。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh"> $ curl https://dist.apache.org/repos/dist/dev/dubbo/KEYS &amp;gt;&amp;gt; KEYS &lt;span style="color:#586e75"># download public keys to local directory&lt;/span>
$ gpg --import KEYS &lt;span style="color:#586e75"># import keys&lt;/span>
$ gpg —edit-key liujun
&amp;gt; trust &lt;span style="color:#586e75"># type trust command&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用如下命令检查签名&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">gpg --verify apache-dubbo-2.6.3-source-release.zip.asc apache-dubbo-2.6.3-source-release.zip
gpg --verify apache-dubbo-2.6.3-bin-release.zip.asc apache-dubbo-2.6.3-bin-release.zip
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="检查源码包的文件内容">检查源码包的文件内容&lt;/h3>
&lt;p>解压缩&lt;code>apache-dubbo-${release_version}-source-release.zip&lt;/code>，进行如下检查:&lt;/p>
&lt;ul>
&lt;li>DISCLAIMER exists&lt;/li>
&lt;li>LICENSE and NOTICE exists and contents are good&lt;/li>
&lt;li>All files and no binary files exist&lt;/li>
&lt;li>All files has standard ASF License header&lt;/li>
&lt;li>Can compile from source&lt;/li>
&lt;li>All unit tests can pass
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn clean &lt;span style="color:#b58900">test&lt;/span> &lt;span style="color:#586e75"># This will run all unit tests&lt;/span>
&lt;span style="color:#586e75"># you can also open rat and style plugin to check if every file meets requirements.&lt;/span>
mvn clean &lt;span style="color:#b58900">test&lt;/span> -Drat.skip&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span> -Dcheckstyle.skip&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Release candidates match with corresponding tags, you can find tag link and hash in vote email.
&lt;ul>
&lt;li>check the version number in pom.xml are the same&lt;/li>
&lt;li>check there are no extra files or directories in the source package, for example, no empty directories or useless log files，这里需要注意换行符是否一致&lt;br>
&lt;code>diff -r a rc_dir tag_dir&lt;/code>&lt;/li>
&lt;li>check the top n tag commits, dive into the related files and check if the source package has the same changes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="检查三方依赖的合规性">检查三方依赖的合规性&lt;/h3>
&lt;p>按照Apache基金会合规性规定，源码或者是二进制分发包中均不能包含Category X的依赖，其中就常见的是包含了GPL/LGPL的依赖，即使是传递依赖也不行。因此在发版的时候需要通过以下的命令进行检查：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">mvn license:add-third-party -Dlicense.useMissingFile
find . -name THIRD-PARTY.txt | xargs grep -E &lt;span style="color:#2aa198">&amp;#39;GPL|General Public License&amp;#39;&lt;/span> | grep -v Apache | grep -v MIT | grep -v CDDL
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果一个依赖提供了双协议或多重协议，可以选择与Apache最兼容的一个协议。&lt;/p>
&lt;h3 id="检查二进制包的文件内容">检查二进制包的文件内容&lt;/h3>
&lt;p>解压缩&lt;code>apache-dubbo-${release_version}-bin-release.zip&lt;/code>，进行如下检查:&lt;/p>
&lt;ul>
&lt;li>Check signatures are good&lt;/li>
&lt;li>LICENSE and NOTICE exists and contents are good&lt;/li>
&lt;/ul>
&lt;p>注意，如果二进制包里面引入了第三方依赖，则需要更新LICENSE，加入第三方依赖的LICENSE，如果第三方依赖的LICENSE是Apache 2.0，并且对应的项目中包含了NOTICE，还需要更新NOTICE文件&lt;/p>
&lt;h2 id="进入投票">进入投票&lt;/h2>
&lt;p>dubbo毕业之后，投票分只需要一次：&lt;/p>
&lt;ol>
&lt;li>Dubbo社区投票，发起投票邮件到dev@dubbo.apache.org。在社区开发者Review，经过至少72小时并统计到3个同意发版的binding票后（只有PMC的票才是binding），即可进入下一阶段的投票。&lt;/li>
&lt;/ol>
&lt;p>Dubbo社区投票邮件模板：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">Hello Dubbo Community,
This is a call for vote to release Apache Dubbo version 2.7.2.
The release candidates:
https://dist.apache.org/repos/dist/dev/dubbo/2.7.2/
The staging repo:
https://repository.apache.org/content/repositories/orgapachedubbo-1005
Git tag for the release:
https://github.com/apache/dubbo/tree/dubbo-2.7.2
Hash for the release tag:
afab04c53edab38d52275d2a198ea1aff7a4f41e
Release Notes:
https://github.com/apache/dubbo/releases/tag/untagged-4775c0a22c60fca55118
The artifacts have been signed with Key : 28681CB1, which can be found in the keys file:
https://dist.apache.org/repos/dist/dev/dubbo/KEYS
The vote will be open for at least 72 hours or until necessary number of votes are reached.
Please vote accordingly:
[ ] +1 approve
[ ] +0 no opinion
[ ] -1 disapprove with the reason
Thanks,
The Apache Dubbo Team
&lt;/code>&lt;/pre>&lt;/div>&lt;p>宣布投票结果模板：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">We’ve received 3 +1 binding votes and one +1 non-binding vote:
+1 binding, Ian Luo
+1 binding, Huxing Zhang
+1 binding, Jun Liu
+1 non-binding, Jerrick
I will start to release today.
Best regards,
The Apache Dubbo Team
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="正式发布">正式发布&lt;/h2>
&lt;ol>
&lt;li>将&lt;a href="https://dist.apache.org/repos/dist/dev/dubbo">dev&lt;/a>目录下的发布包添加到&lt;a href="https://dist.apache.org/repos/dist/release/dubbo">release&lt;/a>目录下，KEYS有更新的，也需要同步更新。&lt;/li>
&lt;li>删除&lt;a href="https://dist.apache.org/repos/dist/dev/dubbo">dev&lt;/a>目录下的发布包&lt;/li>
&lt;li>删除&lt;a href="https://dist.apache.org/repos/dist/release/dubbo">release&lt;/a>目录下上一个版本的发布包，这些包会被自动保存在&lt;a href="https://archive.apache.org/dist/dubbo">这里&lt;/a>&lt;/li>
&lt;li>发布GitHub上的&lt;a href="https://github.com/apache/dubbo/releases">release notes&lt;/a>&lt;/li>
&lt;li>修改GitHub的Readme文件，将版本号更新到最新发布的版本&lt;/li>
&lt;li>在官网下载&lt;a href="http://dubbo.apache.org/en-us/blog/download.html">页面&lt;/a>上添加最新版本的下载链接。最新的下载链接应该类似&lt;a href="https://www.apache.org/dyn/closer.cgi?path=dubbo/$VERSION/apache-dubbo-$VERSION-source-release.zip">这样&lt;/a>. 同时更新以前版本的下载链接，改为类似&lt;a href="https://archive.apache.org/dist/dubbo/$VERSION/apache-dubbo-$VERSION-bin-release.zip">这样&lt;/a>. 具体可以参考过往的&lt;a href="https://github.com/apache/dubbo-website/blob/asf-site/blog/en-us/download.md">下载链接&lt;/a>&lt;/li>
&lt;li>合并&lt;code>${release-version}-release&lt;/code>分支到对应的主干分支， 然后删除相应的release分支，例如: &lt;code>git push origin --delete 2.7.0-release&lt;/code>&lt;/li>
&lt;li>发邮件到 &lt;code>dev@dubbo.apache.org&lt;/code>
宣布release邮件模板：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">Hello Community,
The Apache Dubbo team is pleased to announce that the
2.6.6 has just been released.
Apache Dubbo™ is a high-performance, java based, open source
RPC framework. Dubbo offers three key functionalities, which include
interface based remote call, fault tolerance &amp;amp; load balancing, and
automatic service registration &amp;amp; discovery.
Both the source release[1] and the maven binary release[2] are available
now, you can also find the detailed release notes here[3].
If you have any usage questions, or have problems when upgrading or find
any problems about enhancements included in this release, please don’t
hesitate to let us know by sending feedback to this mailing list or filing
an issue on GitHub[4].
[1] http://dubbo.apache.org/en-us/blog/download.html
[2] https://repo1.maven.org/maven2/org/apache/dubbo/dubbo
[3] https://github.com/apache/dubbo/releases
[4] https://github.com/apache/dubbo/issues
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="完成maven-convenient-binary发布可选">完成Maven Convenient Binary发布（可选）&lt;/h2>
&lt;p>&lt;strong>repository.apache.org&lt;/strong> nexus仓库的权限已经申请，参见&lt;a href="https://issues.apache.org/jira/browse/INFRA-16451">jira&lt;/a>&lt;/p>
&lt;p>发布jar包到maven仓库，首先访问&lt;a href="https://repository.apache.org">repository.apache.org&lt;/a>, 选择&lt;code>staging repository&lt;/code>, 点击&lt;code>release&lt;/code>按钮。等待一段时间之后，在&lt;a href="https://repository.apache.org/content/repositories/releases/org/apache/dubbo/">这里&lt;/a>确认完整性和正确性. 发布到Maven中央仓库则还需要等待一段时间。可以在&lt;a href="https://repo.maven.apache.org/maven2/org/apache/dubbo">这里&lt;/a>进行确认。&lt;/p>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;h4 id="gpg-signing-failed-inappropriate-ioctl-for-device">gpg: signing failed: Inappropriate ioctl for device&lt;/h4>
&lt;p>If you&amp;rsquo;ve encountered this error, try the following commands:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">export GPG_TTY=$(tty)
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 属性配置</title><link>/zh/docs/v2.7/user/configuration/properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/configuration/properties/</guid><description>
&lt;p>如果你的应用足够简单，例如，不需要多注册中心或多协议，并且需要在spring容器中共享配置，那么，我们可以直接使用 &lt;code>dubbo.properties&lt;/code> 作为默认配置。&lt;/p>
&lt;p>Dubbo 可以自动加载 classpath 根目录下的 dubbo.properties，但是你同样可以使用 JVM 参数来指定路径：&lt;code>-Ddubbo.properties.file=xxx.properties&lt;/code>。&lt;/p>
&lt;h1 id="映射规则">映射规则&lt;/h1>
&lt;p>可以将 xml 的 tag 名和属性名组合起来，用 ‘.’ 分隔。每行一个属性。&lt;/p>
&lt;ul>
&lt;li>&lt;code>dubbo.application.name=foo&lt;/code> 相当于 &lt;code>&amp;lt;dubbo:application name=&amp;quot;foo&amp;quot; /&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>dubbo.registry.address=10.20.153.10:9090&lt;/code> 相当于 &lt;code>&amp;lt;dubbo:registry address=&amp;quot;10.20.153.10:9090&amp;quot; /&amp;gt; &lt;/code>&lt;/li>
&lt;/ul>
&lt;p>如果在 xml 配置中有超过一个的 tag，那么你可以使用 ‘id’ 进行区分。如果你不指定 id，它将作用于所有 tag。&lt;/p>
&lt;ul>
&lt;li>&lt;code>dubbo.protocol.rmi.port=1099&lt;/code> 相当于 &lt;code>&amp;lt;dubbo:protocol id=&amp;quot;rmi&amp;quot; name=&amp;quot;rmi&amp;quot; port=&amp;quot;1099&amp;quot; /&amp;gt; &lt;/code>&lt;/li>
&lt;li>&lt;code>dubbo.registry.china.address=10.20.153.10:9090&lt;/code> 相当于 &lt;code>&amp;lt;dubbo:registry id=&amp;quot;china&amp;quot; address=&amp;quot;10.20.153.10:9090&amp;quot; /&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>如下，是一个典型的 dubbo.properties 配置样例。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">dubbo.application.name=foo
dubbo.application.owner=bar
dubbo.registry.address=10.20.153.10:9090
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="重写与优先级">重写与优先级&lt;/h2>
&lt;p>&lt;img src="/imgs/user/dubbo-properties-override.jpg" alt="properties-override">&lt;/p>
&lt;p>优先级从高到低：&lt;/p>
&lt;ul>
&lt;li>JVM -D 参数：当你部署或者启动应用时，它可以轻易地重写配置，比如，改变 dubbo 协议端口；&lt;/li>
&lt;li>XML：XML 中的当前配置会重写 dubbo.properties 中的；&lt;/li>
&lt;li>Properties：默认配置，仅仅作用于以上两者没有配置时。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>如果在 classpath 下有超过一个 dubbo.properties 文件，比如，两个 jar 包都各自包含了 dubbo.properties，dubbo 将随机选择一个加载，并且打印错误日志。&lt;/li>
&lt;li>如果 &lt;code>id&lt;/code> 没有在 &lt;code>protocol&lt;/code> 中配置，将使用 &lt;code>name&lt;/code> 作为默认属性。&lt;/li>
&lt;/ol></description></item><item><title>Docs: 快速开始</title><link>/zh/docs/v2.7/user/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/quick-start/</guid><description>
&lt;p>Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 &lt;a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html">Spring 的 Schema 扩展&lt;/a> 进行加载。&lt;/p>
&lt;p>如果不想使用 Spring 配置，可以通过 &lt;a href="../configuration/api">API 的方式&lt;/a> 进行调用。&lt;/p>
&lt;h2 id="服务提供者">服务提供者&lt;/h2>
&lt;p>完整安装步骤，请参见：&lt;a href="../../admin/install/provider-demo">示例提供者安装&lt;/a>&lt;/p>
&lt;h3 id="定义服务接口">定义服务接口&lt;/h3>
&lt;p>DemoService.java &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> org.apache.dubbo.demo&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
String &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String name&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="在服务提供方实现接口">在服务提供方实现接口&lt;/h3>
&lt;p>DemoServiceImpl.java &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">
&lt;span style="color:#719e07">package&lt;/span> org.apache.dubbo.demo.provider&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.demo.DemoService&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> DemoService &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> String &lt;span style="color:#268bd2">sayHello&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String name&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="用-spring-配置声明暴露服务">用 Spring 配置声明暴露服务&lt;/h3>
&lt;p>provider.xml：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#719e07">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:application&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;hello-world-app&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 使用multicast广播注册中心暴露服务地址 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;multicast://224.5.6.7:1234&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 用dubbo协议在20880端口暴露服务 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34;&lt;/span> ref=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 和本地bean一样实现服务 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span> class=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.demo.provider.DemoServiceImpl&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加载-spring-配置">加载 Spring 配置&lt;/h3>
&lt;p>Provider.java：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">import&lt;/span> org.springframework.context.support.ClassPathXmlApplicationContext&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Provider&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String&lt;span style="color:#719e07">[]&lt;/span> args&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> Exception &lt;span style="color:#719e07">{&lt;/span>
ClassPathXmlApplicationContext context &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ClassPathXmlApplicationContext&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[]{&lt;/span>&lt;span style="color:#2aa198">&amp;#34;META-INF/spring/dubbo-demo-provider.xml&amp;#34;&lt;/span>&lt;span style="color:#719e07">});&lt;/span>
context&lt;span style="color:#719e07">.&lt;/span>start&lt;span style="color:#719e07">();&lt;/span>
System&lt;span style="color:#719e07">.&lt;/span>in&lt;span style="color:#719e07">.&lt;/span>read&lt;span style="color:#719e07">();&lt;/span> &lt;span style="color:#586e75">// 按任意键退出
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="服务消费者">服务消费者&lt;/h2>
&lt;p>完整安装步骤，请参见：&lt;a href="../admin/install/consumer-demo.md">示例消费者安装&lt;/a>&lt;/p>
&lt;h3 id="通过-spring-配置引用远程服务">通过 Spring 配置引用远程服务&lt;/h3>
&lt;p>consumer.xml：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#719e07">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;beans&lt;/span> xmlns=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
xmlns:xsi=&lt;span style="color:#2aa198">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
xmlns:dubbo=&lt;span style="color:#2aa198">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
xsi:schemaLocation=&lt;span style="color:#2aa198">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:application&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;consumer-of-helloworld-app&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;multicast://224.5.6.7:1234&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> id=&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加载spring配置并调用远程服务">加载Spring配置，并调用远程服务&lt;/h3>
&lt;p>Consumer.java &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">import&lt;/span> org.springframework.context.support.ClassPathXmlApplicationContext&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.demo.DemoService&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Consumer&lt;/span> &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>&lt;span style="color:#719e07">(&lt;/span>String&lt;span style="color:#719e07">[]&lt;/span> args&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> Exception &lt;span style="color:#719e07">{&lt;/span>
ClassPathXmlApplicationContext context &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ClassPathXmlApplicationContext&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[]&lt;/span> &lt;span style="color:#719e07">{&lt;/span>&lt;span style="color:#2aa198">&amp;#34;META-INF/spring/dubbo-demo-consumer.xml&amp;#34;&lt;/span>&lt;span style="color:#719e07">});&lt;/span>
context&lt;span style="color:#719e07">.&lt;/span>start&lt;span style="color:#719e07">();&lt;/span>
DemoService demoService &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">(&lt;/span>DemoService&lt;span style="color:#719e07">)&lt;/span>context&lt;span style="color:#719e07">.&lt;/span>getBean&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;demoService&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 获取远程服务代理
&lt;/span>&lt;span style="color:#586e75">&lt;/span> String hello &lt;span style="color:#719e07">=&lt;/span> demoService&lt;span style="color:#719e07">.&lt;/span>sayHello&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;world&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 执行远程方法
&lt;/span>&lt;span style="color:#586e75">&lt;/span> System&lt;span style="color:#719e07">.&lt;/span>out&lt;span style="color:#719e07">.&lt;/span>println&lt;span style="color:#719e07">(&lt;/span> hello &lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 显示调用结果
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>该接口需单独打包，在服务提供方和消费方共享 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>对服务消费方隐藏实现 &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>也可以使用 IoC 注入 &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: 新贡献者向导</title><link>/zh/docs/contribution-guidelines/contributor/new-contributor-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/contribution-guidelines/contributor/new-contributor-guide_dev/</guid><description>
&lt;p>这篇向导旨在给正在准备向 Dubbo 提交贡献的新手提供指导。&lt;/p>
&lt;h3 id="邮件列表描述">邮件列表描述&lt;/h3>
&lt;p>邮件列表是 Dubbo 官方推荐的讨论方式，所有与 Dubbo 相关的内容都可以在这里讨论，请点击 &lt;a href="https://github.com/apache/dubbo/issues/1393">issue&lt;/a> 了解更多关于邮件列表订阅的内容&lt;/p>
&lt;p>如需订阅如下邮件列表，请参考 &lt;a href="/zh-cn/docs/developers/contributor-guide/mailing-list-subscription-guide_dev.html">邮件列表订阅向导&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="mailto:dev@dubbo.apache.org">dev@dubbo.apache.org&lt;/a>：开发邮件列表，您在使用或者开发 Dubbo 的过程中遇到的任何问题，都可以在这里进行提问。&lt;/li>
&lt;li>&lt;a href="mailto:commits@dubbo.apache.org">commits@dubbo.apache.org&lt;/a>：所有的提交内容都会推送到这个邮件列表，如果您对 Dubbo 的进展感兴趣，可以订阅这个邮件列表。&lt;/li>
&lt;li>&lt;a href="mailto:issues@dubbo.apache.org">issues@dubbo.apache.org&lt;/a>：所有的 JIRA &lt;a href="https://issues.apache.org/jira/projects/DUBBO/issues">issues&lt;/a> 和修改信息都会推送到这个邮件列表。Dubbo 社区已经决定使用 github issues 代替 JIRA issues，因此大部分 issues 将由 github issues 进行跟踪。JIRA issues 用于跟踪 ASF 相关问题。&lt;/li>
&lt;/ul>
&lt;h3 id="报告问题">报告问题&lt;/h3>
&lt;h3 id="发送-pull-request">发送 pull request&lt;/h3>
&lt;ul>
&lt;li>参考&lt;a href="https://github.com/apache/dubbo/blob/master/PULL_REQUEST_TEMPLATE.md">pull request template&lt;/a>中的检查列表&lt;/li>
&lt;li>在您发送 pull request 之前，请同步您的 github 仓库和远程仓库，这会使您的 pull request 简单明了，具体操作请看如下所示步骤：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git remote add upstream git@github.com:apache/dubbo.git
git fetch upstream
git rebase upstream/master
git checkout -b your_awesome_patch
... add some work
git push origin your_awesome_patch
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="编码规范">编码规范&lt;/h3>
&lt;p>请按照&lt;a href="https://github.com/apache/dubbo/blob/master/CONTRIBUTING.md">CONTRIBUTING.md&lt;/a>中的编码规范对自己的代码进行检查。&lt;/p>
&lt;h3 id="参与发布投票">参与发布投票&lt;/h3>
&lt;p>参与发布投票是一种重要的贡献社区的方式，Dubbo 社区非常欢迎和鼓励任何人参与投票，每当一个版本需要正式发布的时候，会在开发者邮件列表上进行发布投票，只有当投票取得通过之后，才会正式发布，可以参考这个&lt;a href="https://wiki.apache.org/incubator/IncubatorReleaseChecklist">检查列表&lt;/a>对源码进行合规性检查。如果有任何问题，可以在开发者邮件列表上提问。&lt;/p></description></item><item><title>Docs: 框架设计</title><link>/zh/docs/v2.7/dev/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/design/</guid><description>
&lt;h2 id="整体设计">整体设计&lt;/h2>
&lt;p>&lt;img src="/imgs/dev/dubbo-framework.jpg" alt="/dev-guide/images/dubbo-framework.jpg">&lt;/p>
&lt;p>图例说明：&lt;/p>
&lt;ul>
&lt;li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。&lt;/li>
&lt;li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。&lt;/li>
&lt;li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。&lt;/li>
&lt;li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。&lt;/li>
&lt;/ul>
&lt;h2 id="各层说明">各层说明&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>config 配置层&lt;/strong>：对外配置接口，以 &lt;code>ServiceConfig&lt;/code>, &lt;code>ReferenceConfig&lt;/code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;/li>
&lt;li>&lt;strong>proxy 服务代理层&lt;/strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 &lt;code>ServiceProxy&lt;/code> 为中心，扩展接口为 &lt;code>ProxyFactory&lt;/code>&lt;/li>
&lt;li>&lt;strong>registry 注册中心层&lt;/strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 &lt;code>RegistryFactory&lt;/code>, &lt;code>Registry&lt;/code>, &lt;code>RegistryService&lt;/code>&lt;/li>
&lt;li>&lt;strong>cluster 路由层&lt;/strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 &lt;code>Invoker&lt;/code> 为中心，扩展接口为 &lt;code>Cluster&lt;/code>, &lt;code>Directory&lt;/code>, &lt;code>Router&lt;/code>, &lt;code>LoadBalance&lt;/code>&lt;/li>
&lt;li>&lt;strong>monitor 监控层&lt;/strong>：RPC 调用次数和调用时间监控，以 &lt;code>Statistics&lt;/code> 为中心，扩展接口为 &lt;code>MonitorFactory&lt;/code>, &lt;code>Monitor&lt;/code>, &lt;code>MonitorService&lt;/code>&lt;/li>
&lt;li>&lt;strong>protocol 远程调用层&lt;/strong>：封装 RPC 调用，以 &lt;code>Invocation&lt;/code>, &lt;code>Result&lt;/code> 为中心，扩展接口为 &lt;code>Protocol&lt;/code>, &lt;code>Invoker&lt;/code>, &lt;code>Exporter&lt;/code>&lt;/li>
&lt;li>&lt;strong>exchange 信息交换层&lt;/strong>：封装请求响应模式，同步转异步，以 &lt;code>Request&lt;/code>, &lt;code>Response&lt;/code> 为中心，扩展接口为 &lt;code>Exchanger&lt;/code>, &lt;code>ExchangeChannel&lt;/code>, &lt;code>ExchangeClient&lt;/code>, &lt;code>ExchangeServer&lt;/code>&lt;/li>
&lt;li>&lt;strong>transport 网络传输层&lt;/strong>：抽象 mina 和 netty 为统一接口，以 &lt;code>Message&lt;/code> 为中心，扩展接口为 &lt;code>Channel&lt;/code>, &lt;code>Transporter&lt;/code>, &lt;code>Client&lt;/code>, &lt;code>Server&lt;/code>, &lt;code>Codec&lt;/code>&lt;/li>
&lt;li>&lt;strong>serialize 数据序列化层&lt;/strong>：可复用的一些工具，扩展接口为 &lt;code>Serialization&lt;/code>, &lt;code>ObjectInput&lt;/code>, &lt;code>ObjectOutput&lt;/code>, &lt;code>ThreadPool&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="关系说明">关系说明&lt;/h2>
&lt;ul>
&lt;li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。&lt;/li>
&lt;li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。&lt;/li>
&lt;li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。&lt;/li>
&lt;li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。&lt;/li>
&lt;li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。&lt;/li>
&lt;li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。&lt;/li>
&lt;/ul>
&lt;h2 id="模块分包">模块分包&lt;/h2>
&lt;p>&lt;img src="/imgs/dev/dubbo-modules.jpg" alt="/dev-guide/images/dubbo-modules.jpg">&lt;/p>
&lt;p>模块说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>dubbo-common 公共逻辑模块&lt;/strong>：包括 Util 类和通用模型。&lt;/li>
&lt;li>&lt;strong>dubbo-remoting 远程通讯模块&lt;/strong>：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。&lt;/li>
&lt;li>&lt;strong>dubbo-rpc 远程调用模块&lt;/strong>：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。&lt;/li>
&lt;li>&lt;strong>dubbo-cluster 集群模块&lt;/strong>：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。&lt;/li>
&lt;li>&lt;strong>dubbo-registry 注册中心模块&lt;/strong>：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。&lt;/li>
&lt;li>&lt;strong>dubbo-monitor 监控模块&lt;/strong>：统计服务调用次数，调用时间的，调用链跟踪的服务。&lt;/li>
&lt;li>&lt;strong>dubbo-config 配置模块&lt;/strong>：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。&lt;/li>
&lt;li>&lt;strong>dubbo-container 容器模块&lt;/strong>：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。&lt;/li>
&lt;/ul>
&lt;p>整体上按照分层结构进行分包，与分层的不同点在于：&lt;/p>
&lt;ul>
&lt;li>container 为服务容器，用于部署运行服务，没有在层中画出。&lt;/li>
&lt;li>protocol 层和 proxy 层都放在 rpc 模块中，这两层是 rpc 的核心，在不需要集群也就是只有一个提供者时，可以只使用这两层完成 rpc 调用。&lt;/li>
&lt;li>transport 层和 exchange 层都放在 remoting 模块中，为 rpc 调用的通讯基础。&lt;/li>
&lt;li>serialize 层放在 common 模块中，以便更大程度复用。&lt;/li>
&lt;/ul>
&lt;h2 id="依赖关系">依赖关系&lt;/h2>
&lt;p>&lt;img src="/imgs/dev/dubbo-relation.jpg" alt="/dev-guide/images/dubbo-relation.jpg">&lt;/p>
&lt;p>图例说明：&lt;/p>
&lt;ul>
&lt;li>图中小方块 Protocol, Cluster, Proxy, Service, Container, Registry, Monitor 代表层或模块，蓝色的表示与业务有交互，绿色的表示只对 Dubbo 内部交互。&lt;/li>
&lt;li>图中背景方块 Consumer, Provider, Registry, Monitor 代表部署逻辑拓扑节点。&lt;/li>
&lt;li>图中蓝色虚线为初始化时调用，红色虚线为运行时异步调用，红色实线为运行时同步调用。&lt;/li>
&lt;li>图中只包含 RPC 的层，不包含 Remoting 的层，Remoting 整体都隐含在 Protocol 中。&lt;/li>
&lt;/ul>
&lt;h2 id="调用链">调用链&lt;/h2>
&lt;p>展开总设计图的红色调用链，如下：&lt;/p>
&lt;p>&lt;img src="/imgs/dev/dubbo-extension.jpg" alt="/dev-guide/images/dubbo-extension.jpg">&lt;/p>
&lt;h2 id="暴露服务时序">暴露服务时序&lt;/h2>
&lt;p>展开总设计图左边服务提供方暴露服务的蓝色初始化链，时序图如下：&lt;/p>
&lt;p>&lt;img src="/imgs/dev/dubbo-export.jpg" alt="/dev-guide/images/dubbo-export.jpg">&lt;/p>
&lt;h2 id="引用服务时序">引用服务时序&lt;/h2>
&lt;p>展开总设计图右边服务消费方引用服务的蓝色初始化链，时序图如下：&lt;/p>
&lt;p>&lt;img src="/imgs/dev/dubbo-refer.jpg" alt="/dev-guide/images/dubbo-refer.jpg">&lt;/p>
&lt;h2 id="领域模型">领域模型&lt;/h2>
&lt;p>在 Dubbo 的核心领域模型中：&lt;/p>
&lt;ul>
&lt;li>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。&lt;/li>
&lt;li>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。&lt;/li>
&lt;li>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。&lt;/li>
&lt;/ul>
&lt;h2 id="基本设计原则">基本设计原则&lt;/h2>
&lt;ul>
&lt;li>采用 Microkernel + Plugin 模式，Microkernel 只负责组装 Plugin，Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换。&lt;/li>
&lt;li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。&lt;/li>
&lt;/ul>
&lt;p>更多设计原则参见：&lt;a href="../principals/">框架设计原则&lt;/a>&lt;/p></description></item><item><title>Docs: 消费者配置</title><link>/zh/docs/v2.7/user/languages/erlang/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/languages/erlang/reference/</guid><description>
&lt;h2 id="基础配置">基础配置&lt;/h2>
&lt;p>消费者配置项需要添加到 &lt;code>sys.config&lt;/code> 文件 &lt;code>dubboerl&lt;/code> 应用配置项里。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-erlang" data-lang="erlang">{dubboerl,[
&lt;span style="color:#586e75">%% other config ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> {consumer,[
{&lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;interface fullname&amp;#34;&lt;/span>&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span>,[&lt;span style="color:#268bd2">Option&lt;/span>]},
&lt;span style="color:#586e75">%% eg:
&lt;/span>&lt;span style="color:#586e75">&lt;/span> {&lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&lt;/span>&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span>,[]},
]}
]}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Option 配置项待添加中。&lt;/p></description></item><item><title>Docs: 示例提供者安装</title><link>/zh/docs/v2.7/admin/install/provider-demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/admin/install/provider-demo/</guid><description>
&lt;p>安装：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/apache/dubbo.git
&lt;span style="color:#b58900">cd&lt;/span> dubbo/dubbo-demo/dubbo-demo-xml
运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application
如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#b58900">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">resources/spring/dubbo-provider.xml
修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如：
&amp;lt;dubbo:registry &lt;span style="color:#268bd2">address&lt;/span>&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>/&amp;gt;
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 自动加载环境变量</title><link>/zh/docs/v2.7/user/configuration/environment-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/configuration/environment-variables/</guid><description>
&lt;p>从 2.7.3 版本开始，Dubbo 会自动从约定 key 中读取配置，并将配置以 Key-Value 的形式写入到URL中。&lt;/p>
&lt;p>支持的 key 有以下两个：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>dubbo.labels&lt;/code>，指定一些列配置到 URL 中的键值对，通常通过 JVM -D 或系统环境变量指定。&lt;/p>
&lt;p>增加以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># JVM
-Ddubbo.labels = &amp;#34;tag1=value1; tag2=value2&amp;#34;
# 环境变量
DUBBO_LABELS = &amp;#34;tag1=value1; tag2=value2&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终生成的 URL 会包含 tag1、tag2 两个 key: &lt;code>dubbo://xxx?tag1=value1&amp;amp;tag2=value2&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dubbo.env.keys&lt;/code>，指定环境变量 key 值，Dubbo 会尝试从环境变量加载每个 key&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback"># JVM
-Ddubbo.env.keys = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34;
# 环境变量
DUBBO_ENV_KEYS = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终生成的 URL 会包含 DUBBO_TAG1、DUBBO_TAG2 两个 key: &lt;code>dubbo://xxx?DUBBO_TAG1=value1&amp;amp;DUBBO_TAG2=value2&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: 调用拦截扩展</title><link>/zh/docs/v2.7/dev/impls/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/impls/filter/</guid><description>
&lt;h2 id="扩展说明">扩展说明&lt;/h2>
&lt;p>服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。&lt;/p>
&lt;p>约定：&lt;/p>
&lt;ul>
&lt;li>用户自定义 filter 默认在内置 filter 之后。&lt;/li>
&lt;li>特殊值 &lt;code>default&lt;/code>，表示缺省扩展点插入的位置。比如：&lt;code>filter=&amp;quot;xxx,default,yyy&amp;quot;&lt;/code>，表示 &lt;code>xxx&lt;/code> 在缺省 filter 之前，&lt;code>yyy&lt;/code> 在缺省 filter 之后。&lt;/li>
&lt;li>特殊符号 &lt;code>-&lt;/code>，表示剔除。比如：&lt;code>filter=&amp;quot;-foo1&amp;quot;&lt;/code>，剔除添加缺省扩展点 &lt;code>foo1&lt;/code>。比如：&lt;code>filter=&amp;quot;-default&amp;quot;&lt;/code>，剔除添加所有缺省扩展点。&lt;/li>
&lt;li>provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&lt;code>&amp;lt;dubbo:provider filter=&amp;quot;xxx,yyy&amp;quot;/&amp;gt;&lt;/code> 和 &lt;code>&amp;lt;dubbo:service filter=&amp;quot;aaa,bbb&amp;quot; /&amp;gt;&lt;/code>，则 &lt;code>xxx&lt;/code>,&lt;code>yyy&lt;/code>,&lt;code>aaa&lt;/code>,&lt;code>bbb&lt;/code> 均会生效。如果要覆盖，需配置：&lt;code>&amp;lt;dubbo:service filter=&amp;quot;-xxx,-yyy,aaa,bbb&amp;quot; /&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="扩展接口">扩展接口&lt;/h2>
&lt;p>&lt;code>org.apache.dubbo.rpc.Filter&lt;/code>&lt;/p>
&lt;h2 id="扩展配置">扩展配置&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#586e75">&amp;lt;!-- 消费方调用过程拦截 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> filter=&lt;span style="color:#2aa198">&amp;#34;xxx,yyy&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 消费方调用过程缺省拦截器，将拦截所有reference --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:consumer&lt;/span> filter=&lt;span style="color:#2aa198">&amp;#34;xxx,yyy&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 提供方调用过程拦截 --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> filter=&lt;span style="color:#2aa198">&amp;#34;xxx,yyy&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#586e75">&amp;lt;!-- 提供方调用过程缺省拦截器，将拦截所有service --&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:provider&lt;/span> filter=&lt;span style="color:#2aa198">&amp;#34;xxx,yyy&amp;#34;&lt;/span>&lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="已知扩展">已知扩展&lt;/h2>
&lt;ul>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.EchoFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.GenericFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.GenericImplFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.TokenFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.AccessLogFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.CountFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ActiveLimitFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ClassLoaderFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ContextFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ConsumerContextFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ExceptionFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.ExecuteLimitFilter&lt;/code>&lt;/li>
&lt;li>&lt;code>org.apache.dubbo.rpc.filter.DeprecatedFilter&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="扩展示例">扩展示例&lt;/h2>
&lt;p>Maven 项目结构：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">src
|-main
|-java
|-com
|-xxx
|-XxxFilter.java (实现Filter接口)
|-resources
|-META-INF
|-dubbo
|-org.apache.dubbo.rpc.Filter (纯文本文件，内容为：xxx=com.xxx.XxxFilter)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>XxxFilter.java：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">package&lt;/span> com.xxx&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Filter&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Invoker&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Invocation&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.RpcException&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Filter &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#268bd2">public&lt;/span> Result &lt;span style="color:#268bd2">invoke&lt;/span>&lt;span style="color:#719e07">(&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> invoker&lt;span style="color:#719e07">,&lt;/span> Invocation invocation&lt;span style="color:#719e07">)&lt;/span> &lt;span style="color:#268bd2">throws&lt;/span> RpcException &lt;span style="color:#719e07">{&lt;/span>
&lt;span style="color:#586e75">// before filter ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> Result result &lt;span style="color:#719e07">=&lt;/span> invoker&lt;span style="color:#719e07">.&lt;/span>invoke&lt;span style="color:#719e07">(&lt;/span>invocation&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// after filter ...
&lt;/span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> result&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;span style="color:#719e07">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>META-INF/dubbo/org.apache.dubbo.rpc.Filter：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">xxx=com.xxx.XxxFilter
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 配置设计</title><link>/zh/docs/v2.7/dev/principals/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/dev/principals/configuration/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="http://javatar.iteye.com/blog/949527">http://javatar.iteye.com/blog/949527&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Dubbo 现在的设计是完全无侵入，也就是使用者只依赖于配置契约。经过多个版本的发展，为了满足各种需求场景，配置越来越多。为了保持兼容，配置只增不减，里面潜伏着各种风格，约定，规则。新版本也将配置做了一次调整，将想到的一些记在这，备忘。&lt;/p>
&lt;h2 id="配置分类">配置分类&lt;/h2>
&lt;p>首先，配置的用途是有多种的，大致可以分为：&lt;/p>
&lt;ol start="0">
&lt;li>环境配置，比如：连接数，超时等配置。&lt;/li>
&lt;li>描述配置，比如：服务接口描述，服务版本等。&lt;/li>
&lt;li>扩展配置，比如：协议扩展，策略扩展等。&lt;/li>
&lt;/ol>
&lt;h2 id="配置格式">配置格式&lt;/h2>
&lt;p>通常环境配置，用 properties 配置会比较方便，因为都是一些离散的简单值，用 key-value 配置可以减少配置的学习成本。&lt;/p>
&lt;p>而描述配置，通常信息比较多，甚至有层次关系，用 xml 配置会比较方便，因为树结构的配置表现力更强。如果非常复杂，也可以考自定义 DSL 做为配置。有时候这类配置也可以用 Annotation 代替， 因为这些配置和业务逻辑相关，放在代码里也是合理的。&lt;/p>
&lt;p>另外扩展配置，可能不尽相同。如果只是策略接口实现类替换，可以考虑 properties 等结构。如果有复杂的生命周期管理，可能需要 XML 等配置。有时候扩展会通过注册接口的方式提供。&lt;/p>
&lt;h2 id="配置加载">配置加载&lt;/h2>
&lt;p>对于环境配置，在 java 世界里，比较常规的做法，是在 classpath 下约定一个以项目为名称的 properties 配置，比如：log4j.properties，velocity.properties等。产品在初始化时，自动从 classpath 下加载该配置。我们平台的很多项目也使用类似策略，如：dubbo.properties，comsat.xml 等。这样有它的优势，就是基于约定，简化了用户对配置加载过程的干预。但同样有它的缺点，当 classpath 存在同样的配置时，可能误加载，以及在 ClassLoader 隔离时，可能找不到配置，并且，当用户希望将配置放到统一的目录时，不太方便。&lt;/p>
&lt;p>而对于描述配置，因为要参与业务逻辑，通常会嵌到应用的生命周期管理中。现在使用 spring 的项目越来越多，直接使用 spring 配置的比较普遍，而且 spring 允许自定义 schema，配置简化后很方便。当然，也有它的缺点，就是强依赖 spring，可以提编程接口做了配套方案。&lt;/p>
&lt;p>在 Dubbo 既存在描述配置也有环境配置。一部分用 spring 的 schema 做配置加载，一部分从 classpath 扫描 properties 做配置加载。在新版本中做了一个优先级约定，统一以 spring 的 schema 驱动配置加载，dubbo.properties作为配置补充。&lt;/p>
&lt;p>同时，在 Spring 的场景下，除了使用 schema 外，还支持完全以 application.properties 的方式配置：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml"># Dubbo Application
## The default value of dubbo.application.name is ${spring.application.name}
## dubbo.application.name=${spring.application.name}
# Dubbo Protocol
dubbo.protocol.name=dubbo
dubbo.protocol.port=12345
## Dubbo Registry
dubbo.registry.address=N/A
&lt;/code>&lt;/pre>&lt;/div>&lt;p>扩展配置，通常对配置的聚合要求比较高。因为产品需要发现第三方实现，将其加入产品内部。在 java 世界里，通常是约定在每个 jar 包下放一个指定文件加载，比如：eclipse 的 plugin.xml，struts2 的 struts-plugin.xml 等，这类配置可以考虑 java 标准的服务发现机制，即在 jar 包的 META-INF/services 下放置接口类全名文件，内容为每行一个实现类类名，就像 jdk 中的加密算法扩展，脚本引擎扩展，新的 JDBC 驱动等，都是采用这种方式。参见：&lt;a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">ServiceProvider 规范&lt;/a>。&lt;/p>
&lt;p>Dubbo 旧版本通过约定在每个 jar 包下，放置名为 dubbo-context.xml 的 spring 配置进行扩展与集成，新版本改成用 jdk 自带的 META-INF/services 方式，去掉过多的 spring 依赖。&lt;/p>
&lt;h2 id="可编程配置">可编程配置&lt;/h2>
&lt;p>配置的可编程性是非常必要的，不管你以何种方式加载配置文件，都应该提供一个编程的配置方式，允许用户不使用配置文件，直接用代码完成配置过程。因为一个产品，尤其是组件类产品，通常需要和其它产品协作使用，当用户集成你的产品时，可能需要适配配置方式。&lt;/p>
&lt;p>Dubbo 新版本提供了与 xml 配置一对一的配置类，如：ServiceConfig 对应 &lt;code>&amp;lt;dubbo:service /&amp;gt;&lt;/code>，并且属性也一对一，这样有利于文件配置与编程配置的一致性理解，减少学习成本。&lt;/p>
&lt;h2 id="配置缺省值">配置缺省值&lt;/h2>
&lt;p>配置的缺省值，通常是设置一个常规环境的合理值，这样可以减少用户的配置量。通常建议以线上环境为参考值，开发环境可以通过修改配置适应。缺省值的设置，最好在最外层的配置加载就做处理。程序底层如果发现配置不正确，就应该直接报错，容错在最外层做。如果在程序底层使用时，发现配置值不合理，就填一个缺省值，很容易掩盖表面问题，而引发更深层次的问题。并且配置的中间传递层，很可能并不知道底层使用了一个缺省值，一些中间的检测条件就可能失效。Dubbo 就出现过这样的问题，中间层用“地址”做为缓存 Key， 而底层，给“地址”加了一个缺省端口号，导致不加端口号的“地址”和加了缺省端口的“地址”并没有使用相同的缓存。&lt;/p>
&lt;h2 id="配置一致性">配置一致性&lt;/h2>
&lt;p>配置总会隐含一些风格或潜规则，应尽可能保持其一致性。比如：很多功能都有开关，然后有一个配置值：&lt;/p>
&lt;ol start="0">
&lt;li>是否使用注册中心，注册中心地址。&lt;/li>
&lt;li>是否允许重试，重试次数。&lt;/li>
&lt;/ol>
&lt;p>你可以约定：&lt;/p>
&lt;ol start="0">
&lt;li>每个都是先配置一个 boolean 类型的开关，再配置一个值。&lt;/li>
&lt;li>用一个无效值代表关闭，N/A地址，0重试次数等。&lt;/li>
&lt;/ol>
&lt;p>不管选哪种方式，所有配置项，都应保持同一风格，Dubbo 选的是第二种。相似的还有，超时时间，重试时间，定时器间隔时间。如果一个单位是秒，另一个单位是毫秒(C3P0的配置项就是这样)，配置人员会疯掉。&lt;/p>
&lt;h2 id="配置覆盖">配置覆盖&lt;/h2>
&lt;p>提供配置时，要同时考虑开发人员，测试人员，配管人员，系统管理员。测试人员是不能修改代码的，而测试的环境很可能较为复杂，需要为测试人员留一些“后门”，可以在外围修改配置项。就像 spring 的 PropertyPlaceholderConfigurer 配置，支持 &lt;code>SYSTEM_PROPERTIES_MODE_OVERRIDE&lt;/code>，可以通过 JVM 的 -D 参数，或者像 hosts 一样约定一个覆盖配置文件，在程序外部，修改部分配置，便于测试。&lt;/p>
&lt;p>Dubbo 支持通过 JVM 参数 &lt;code>-Dcom.xxx.XxxService=dubbo://10.1.1.1:1234 &lt;/code> 直接使远程服务调用绕过注册中心，进行点对点测试。还有一种情况，开发人员增加配置时，都会按线上的部署情况做配置，如：&lt;code>&amp;lt;dubbo:registry address=&amp;quot;${dubbo.registry.address}&amp;quot; /&amp;gt;&lt;/code> 因为线上只有一个注册中心，这样的配置是没有问题的，而测试环境可能有两个注册中心，测试人员不可能去修改配置，改为：
&lt;code>&amp;lt;dubbo:registry address=&amp;quot;${dubbo.registry.address1}&amp;quot; /&amp;gt;&lt;/code>，
&lt;code>&amp;lt;dubbo:registry address=&amp;quot;${dubbo.registry.address2}&amp;quot; /&amp;gt;&lt;/code>，所以这个地方，Dubbo 支持在 ${dubbo.registry.address} 的值中，通过竖号分隔多个注册中心地址，用于表示多注册中心地址。&lt;/p>
&lt;h2 id="配置继承">配置继承&lt;/h2>
&lt;p>配置也存在“重复代码”，也存在“泛化与精化”的问题。比如：Dubbo 的超时时间设置，每个服务，每个方法，都应该可以设置超时时间。但很多服务不关心超时，如果要求每个方法都配置，是不现实的。所以 Dubbo 采用了方法超时继承服务超时，服务超时再继承缺省超时，没配置时，一层层向上查找。&lt;/p>
&lt;p>另外，Dubbo 旧版本所有的超时时间，重试次数，负载均衡策略等都只能在服务消费方配置。但实际使用过程中发现，服务提供方比消费方更清楚，但这些配置项是在消费方执行时才用到的。新版本，就加入了在服务提供方也能配这些参数，通过注册中心传递到消费方，
做为参考值，如果消费方没有配置，就以提供方的配置为准，相当于消费方继承了提供方的建议配置值。而注册中心在传递配置时，也可以在中途修改配置，这样就达到了治理的目的，继承关系相当于：服务消费者 &amp;ndash;&amp;gt; 注册中心 &amp;ndash;&amp;gt; 服务提供者&lt;/p>
&lt;p>&lt;img src="/imgs/dev/configuration-override.png" alt="configuration-override">&lt;/p>
&lt;h2 id="配置向后兼容">配置向后兼容&lt;/h2>
&lt;p>向前兼容很好办，你只要保证配置只增不减，就基本上能保证向前兼容。但向后兼容，也是要注意的，要为后续加入新的配置项做好准备。如果配置出现一个特殊配置，就应该为这个“特殊”情况约定一个兼容规则，因为这个特殊情况，很有可能在以后还会发生。比如：有一个配置文件是保存“服务=地址”映射关系的，其中有一行特殊，保存的是“注册中心=地址”。现在程序加载时，约定“注册中心”这个Key是特殊的，做特别处理，其它的都是“服务”。然而，新版本发现，要加一项“监控中心=地址”，这时，旧版本的程序会把“监控中心”做为“服务”处理，因为旧代码是不能改的，兼容性就很会很麻烦。如果先前约定“特殊标识+XXX”为特殊处理，后续就会方便很多。&lt;/p>
&lt;p>向后兼容性，可以多向HTML5学习，参见：&lt;a href="http://javatar.iteye.com/blog/949390">HTML5设计原理&lt;/a>&lt;/p></description></item><item><title>Docs: 集群容错</title><link>/zh/docs/v2.7/user/examples/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/examples/fault-tolerent-strategy/</guid><description>
&lt;p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。&lt;/p>
&lt;p>&lt;img src="/imgs/user/cluster.jpg" alt="cluster">&lt;/p>
&lt;p>各节点关系：&lt;/p>
&lt;ul>
&lt;li>这里的 &lt;code>Invoker&lt;/code> 是 &lt;code>Provider&lt;/code> 的一个可调用 &lt;code>Service&lt;/code> 的抽象，&lt;code>Invoker&lt;/code> 封装了 &lt;code>Provider&lt;/code> 地址及 &lt;code>Service&lt;/code> 接口信息&lt;/li>
&lt;li>&lt;code>Directory&lt;/code> 代表多个 &lt;code>Invoker&lt;/code>，可以把它看成 &lt;code>List&amp;lt;Invoker&amp;gt;&lt;/code> ，但与 &lt;code>List&lt;/code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更&lt;/li>
&lt;li>&lt;code>Cluster&lt;/code> 将 &lt;code>Directory&lt;/code> 中的多个 &lt;code>Invoker&lt;/code> 伪装成一个 &lt;code>Invoker&lt;/code>，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个&lt;/li>
&lt;li>&lt;code>Router&lt;/code> 负责从多个 &lt;code>Invoker&lt;/code> 中按路由规则选出子集，比如读写分离，应用隔离等&lt;/li>
&lt;li>&lt;code>LoadBalance&lt;/code> 负责从多个 &lt;code>Invoker&lt;/code> 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选&lt;/li>
&lt;/ul>
&lt;h2 id="集群容错模式">集群容错模式&lt;/h2>
&lt;p>可以自行扩展集群容错策略，参见：&lt;a href="../../../dev/impls/cluster">集群扩展&lt;/a>&lt;/p>
&lt;h3 id="failover-cluster">Failover Cluster&lt;/h3>
&lt;p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 &lt;code>retries=&amp;quot;2&amp;quot;&lt;/code> 来设置重试次数(不含第一次)。&lt;/p>
&lt;p>重试次数配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> retries=&lt;span style="color:#2aa198">&amp;#34;2&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> retries=&lt;span style="color:#2aa198">&amp;#34;2&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;dubbo:method&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;findFoo&amp;#34;&lt;/span> retries=&lt;span style="color:#2aa198">&amp;#34;2&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/dubbo:reference&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">提示&lt;/h4>
该配置为缺省配置
&lt;/div>
&lt;h3 id="failfast-cluster">Failfast Cluster&lt;/h3>
&lt;p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。&lt;/p>
&lt;h3 id="failsafe-cluster">Failsafe Cluster&lt;/h3>
&lt;p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。&lt;/p>
&lt;h3 id="failback-cluster">Failback Cluster&lt;/h3>
&lt;p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。&lt;/p>
&lt;h3 id="forking-cluster">Forking Cluster&lt;/h3>
&lt;p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 &lt;code>forks=&amp;quot;2&amp;quot;&lt;/code> 来设置最大并行数。&lt;/p>
&lt;h3 id="broadcast-cluster">Broadcast Cluster&lt;/h3>
&lt;p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">提示&lt;/h4>
&lt;code>2.1.0&lt;/code> 开始支持
&lt;/div>
&lt;h2 id="集群模式配置">集群模式配置&lt;/h2>
&lt;p>按照以下示例在服务提供方和消费方配置集群模式&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> cluster=&lt;span style="color:#2aa198">&amp;#34;failsafe&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> cluster=&lt;span style="color:#2aa198">&amp;#34;failsafe&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: API 配置</title><link>/zh/docs/v2.7/user/configuration/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/configuration/api/</guid><description>
&lt;p>API 属性与配置项一对一，各属性含义，请参见：&lt;a href="../../references/xml/introduction">配置参考手册&lt;/a>，比如：&lt;code>ApplicationConfig.setName(&amp;quot;xxx&amp;quot;)&lt;/code> 对应 &lt;code>&amp;lt;dubbo:application name=&amp;quot;xxx&amp;quot; /&amp;gt;&lt;/code> &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="服务提供者">服务提供者&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ApplicationConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.RegistryConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ProviderConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ServiceConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> com.xxx.XxxService&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> com.xxx.XxxServiceImpl&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 服务实现
&lt;/span>&lt;span style="color:#586e75">&lt;/span>XxxService xxxService &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> XxxServiceImpl&lt;span style="color:#719e07">();&lt;/span>
&lt;span style="color:#586e75">// 当前应用配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ApplicationConfig application &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig&lt;span style="color:#719e07">();&lt;/span>
application&lt;span style="color:#719e07">.&lt;/span>setName&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 连接注册中心配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>RegistryConfig registry &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RegistryConfig&lt;span style="color:#719e07">();&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setAddress&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;10.20.130.230:9090&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setUsername&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;aaa&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setPassword&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;bbb&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 服务提供者协议配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ProtocolConfig protocol &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ProtocolConfig&lt;span style="color:#719e07">();&lt;/span>
protocol&lt;span style="color:#719e07">.&lt;/span>setName&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
protocol&lt;span style="color:#719e07">.&lt;/span>setPort&lt;span style="color:#719e07">(&lt;/span>12345&lt;span style="color:#719e07">);&lt;/span>
protocol&lt;span style="color:#719e07">.&lt;/span>setThreads&lt;span style="color:#719e07">(&lt;/span>200&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// 服务提供者暴露服务配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;();&lt;/span> &lt;span style="color:#586e75">// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏
&lt;/span>&lt;span style="color:#586e75">&lt;/span>service&lt;span style="color:#719e07">.&lt;/span>setApplication&lt;span style="color:#719e07">(&lt;/span>application&lt;span style="color:#719e07">);&lt;/span>
service&lt;span style="color:#719e07">.&lt;/span>setRegistry&lt;span style="color:#719e07">(&lt;/span>registry&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 多个注册中心可以用setRegistries()
&lt;/span>&lt;span style="color:#586e75">&lt;/span>service&lt;span style="color:#719e07">.&lt;/span>setProtocol&lt;span style="color:#719e07">(&lt;/span>protocol&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 多个协议可以用setProtocols()
&lt;/span>&lt;span style="color:#586e75">&lt;/span>service&lt;span style="color:#719e07">.&lt;/span>setInterface&lt;span style="color:#719e07">(&lt;/span>XxxService&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
service&lt;span style="color:#719e07">.&lt;/span>setRef&lt;span style="color:#719e07">(&lt;/span>xxxService&lt;span style="color:#719e07">);&lt;/span>
service&lt;span style="color:#719e07">.&lt;/span>setVersion&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;1.0.0&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 暴露及注册服务
&lt;/span>&lt;span style="color:#586e75">&lt;/span>service&lt;span style="color:#719e07">.&lt;/span>export&lt;span style="color:#719e07">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="服务消费者">服务消费者&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ApplicationConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.RegistryConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ConsumerConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.config.ReferenceConfig&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#719e07">import&lt;/span> com.xxx.XxxService&lt;span style="color:#719e07">;&lt;/span>
&lt;span style="color:#586e75">// 当前应用配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ApplicationConfig application &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig&lt;span style="color:#719e07">();&lt;/span>
application&lt;span style="color:#719e07">.&lt;/span>setName&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;yyy&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 连接注册中心配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>RegistryConfig registry &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RegistryConfig&lt;span style="color:#719e07">();&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setAddress&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;10.20.130.230:9090&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setUsername&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;aaa&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
registry&lt;span style="color:#719e07">.&lt;/span>setPassword&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;bbb&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#586e75">// 引用远程服务
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;();&lt;/span> &lt;span style="color:#586e75">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
&lt;/span>&lt;span style="color:#586e75">&lt;/span>reference&lt;span style="color:#719e07">.&lt;/span>setApplication&lt;span style="color:#719e07">(&lt;/span>application&lt;span style="color:#719e07">);&lt;/span>
reference&lt;span style="color:#719e07">.&lt;/span>setRegistry&lt;span style="color:#719e07">(&lt;/span>registry&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 多个注册中心可以用setRegistries()
&lt;/span>&lt;span style="color:#586e75">&lt;/span>reference&lt;span style="color:#719e07">.&lt;/span>setInterface&lt;span style="color:#719e07">(&lt;/span>XxxService&lt;span style="color:#719e07">.&lt;/span>class&lt;span style="color:#719e07">);&lt;/span>
reference&lt;span style="color:#719e07">.&lt;/span>setVersion&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;1.0.0&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 和本地bean一样使用xxxService
&lt;/span>&lt;span style="color:#586e75">&lt;/span>XxxService xxxService &lt;span style="color:#719e07">=&lt;/span> reference&lt;span style="color:#719e07">.&lt;/span>get&lt;span style="color:#719e07">();&lt;/span> &lt;span style="color:#586e75">// 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="特殊场景">特殊场景&lt;/h2>
&lt;p>下面只列出不同的地方，其它参见上面的写法&lt;/p>
&lt;h3 id="方法级设置">方法级设置&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#719e07">...&lt;/span>
&lt;span style="color:#586e75">// 方法级配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>List&lt;span style="color:#719e07">&amp;lt;&lt;/span>MethodConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> methods &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&lt;/span>MethodConfig&lt;span style="color:#719e07">&amp;gt;();&lt;/span>
MethodConfig method &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MethodConfig&lt;span style="color:#719e07">();&lt;/span>
method&lt;span style="color:#719e07">.&lt;/span>setName&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;createXxx&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
method&lt;span style="color:#719e07">.&lt;/span>setTimeout&lt;span style="color:#719e07">(&lt;/span>10000&lt;span style="color:#719e07">);&lt;/span>
method&lt;span style="color:#719e07">.&lt;/span>setRetries&lt;span style="color:#719e07">(&lt;/span>0&lt;span style="color:#719e07">);&lt;/span>
methods&lt;span style="color:#719e07">.&lt;/span>add&lt;span style="color:#719e07">(&lt;/span>method&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#586e75">// 引用远程服务
&lt;/span>&lt;span style="color:#586e75">&lt;/span>ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;();&lt;/span> &lt;span style="color:#586e75">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
&lt;/span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">...&lt;/span>
reference&lt;span style="color:#719e07">.&lt;/span>setMethods&lt;span style="color:#719e07">(&lt;/span>methods&lt;span style="color:#719e07">);&lt;/span> &lt;span style="color:#586e75">// 设置方法级配置
&lt;/span>&lt;span style="color:#586e75">&lt;/span>
&lt;span style="color:#719e07">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="点对点直连">点对点直连&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">
&lt;span style="color:#719e07">...&lt;/span>
ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>XxxService&lt;span style="color:#719e07">&amp;gt;();&lt;/span> &lt;span style="color:#586e75">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏
&lt;/span>&lt;span style="color:#586e75">// 如果点对点直连，可以用reference.setUrl()指定目标地址，设置url后将绕过注册中心，
&lt;/span>&lt;span style="color:#586e75">// 其中，协议对应provider.setProtocol()的值，端口对应provider.setPort()的值，
&lt;/span>&lt;span style="color:#586e75">// 路径对应service.setPath()的值，如果未设置path，缺省path为接口名
&lt;/span>&lt;span style="color:#586e75">&lt;/span>reference&lt;span style="color:#719e07">.&lt;/span>setUrl&lt;span style="color:#719e07">(&lt;/span>&lt;span style="color:#2aa198">&amp;#34;dubbo://10.20.130.230:20880/com.xxx.XxxService&amp;#34;&lt;/span>&lt;span style="color:#719e07">);&lt;/span>
&lt;span style="color:#719e07">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>API使用范围说明：API 仅用于 OpenAPI, ESB, Test, Mock 等系统集成，普通服务提供方或消费方，请采用&lt;a href="../xml">XML 配置&lt;/a>方式使用 Dubbo &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: http 协议</title><link>/zh/docs/v2.7/user/references/protocol/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/protocol/http/</guid><description>
&lt;p>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">提示&lt;/h4>
&lt;code>2.3.0&lt;/code> 以上版本支持
&lt;/div>
&lt;h2 id="特性">特性&lt;/h2>
&lt;ul>
&lt;li>连接个数：多连接&lt;/li>
&lt;li>连接方式：短连接&lt;/li>
&lt;li>传输协议：HTTP&lt;/li>
&lt;li>传输方式：同步传输&lt;/li>
&lt;li>序列化：表单序列化&lt;/li>
&lt;li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。&lt;/li>
&lt;li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。&lt;/li>
&lt;/ul>
&lt;h2 id="约束">约束&lt;/h2>
&lt;ul>
&lt;li>参数及返回值需符合 Bean 规范&lt;/li>
&lt;/ul>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>配置协议：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;http&amp;#34;&lt;/span> port=&lt;span style="color:#2aa198">&amp;#34;8080&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 Jetty Server (默认)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> ... server=&lt;span style="color:#2aa198">&amp;#34;jetty&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 Servlet Bridge Server (推荐使用)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> ... server=&lt;span style="color:#2aa198">&amp;#34;servlet&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置 DispatcherServlet：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;servlet&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-name&amp;gt;&lt;/span>dubbo&lt;span style="color:#268bd2">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-class&amp;gt;&lt;/span>org.apache.dubbo.remoting.http.servlet.DispatcherServlet&lt;span style="color:#268bd2">&amp;lt;/servlet-class&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;load-on-startup&amp;gt;&lt;/span>1&lt;span style="color:#268bd2">&amp;lt;/load-on-startup&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servlet&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-mapping&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;servlet-name&amp;gt;&lt;/span>dubbo&lt;span style="color:#268bd2">&amp;lt;/servlet-name&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;url-pattern&amp;gt;&lt;/span>/*&lt;span style="color:#268bd2">&amp;lt;/url-pattern&amp;gt;&lt;/span>
&lt;span style="color:#268bd2">&amp;lt;/servlet-mapping&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，如果使用 servlet 派发请求：&lt;/p>
&lt;ul>
&lt;li>协议的端口 &lt;code>&amp;lt;dubbo:protocol port=&amp;quot;8080&amp;quot; /&amp;gt;&lt;/code> 必须与 servlet 容器的端口相同，&lt;/li>
&lt;li>协议的上下文路径 &lt;code>&amp;lt;dubbo:protocol contextpath=&amp;quot;foo&amp;quot; /&amp;gt;&lt;/code> 必须与 servlet 应用的上下文路径相同。&lt;/li>
&lt;/ul></description></item><item><title>Docs: Redis 注册中心</title><link>/zh/docs/v2.7/user/references/registry/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh/docs/v2.7/user/references/registry/redis/</guid><description>
&lt;p>基于 Redis &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 实现的注册中心。&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">提示&lt;/h4>
&lt;p>从 &lt;code>2.1.0&lt;/code> 版本开始支持。&lt;/p>
&lt;p>Redis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确&lt;/p>
&lt;/div>
&lt;p>&lt;img src="/imgs/user/dubbo-redis-registry.jpg" alt="/user-guide/images/dubbo-redis-registry.jpg">&lt;/p>
&lt;p>使用 Redis 的 Key/Map 结构存储数据结构：&lt;/p>
&lt;ul>
&lt;li>主 Key 为服务名和类型&lt;/li>
&lt;li>Map 中的 Key 为 URL 地址&lt;/li>
&lt;li>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除 [^3]&lt;/li>
&lt;/ul>
&lt;p>使用 Redis 的 Publish/Subscribe 事件通知数据变更：&lt;/p>
&lt;ul>
&lt;li>通过事件的值区分事件类型：&lt;code>register&lt;/code>, &lt;code>unregister&lt;/code>, &lt;code>subscribe&lt;/code>, &lt;code>unsubscribe&lt;/code>&lt;/li>
&lt;li>普通消费者直接订阅指定服务提供者的 Key，只会收到指定服务的 &lt;code>register&lt;/code>, &lt;code>unregister&lt;/code> 事件&lt;/li>
&lt;li>监控中心通过 &lt;code>psubscribe&lt;/code> 功能订阅 &lt;code>/dubbo/*&lt;/code>，会收到所有服务的所有变更事件&lt;/li>
&lt;/ul>
&lt;p>调用过程：&lt;/p>
&lt;ol start="0">
&lt;li>服务提供方启动时，向 &lt;code>Key:/dubbo/com.foo.BarService/providers&lt;/code> 下，添加当前提供者的地址&lt;/li>
&lt;li>并向 &lt;code>Channel:/dubbo/com.foo.BarService/providers&lt;/code> 发送 &lt;code>register&lt;/code> 事件&lt;/li>
&lt;li>服务消费方启动时，从 &lt;code>Channel:/dubbo/com.foo.BarService/providers&lt;/code> 订阅 &lt;code>register&lt;/code> 和 &lt;code>unregister&lt;/code> 事件&lt;/li>
&lt;li>并向 &lt;code>Key:/dubbo/com.foo.BarService/consumers&lt;/code> 下，添加当前消费者的地址&lt;/li>
&lt;li>服务消费方收到 &lt;code>register&lt;/code> 和 &lt;code>unregister&lt;/code> 事件后，从 &lt;code>Key:/dubbo/com.foo.BarService/providers&lt;/code> 下获取提供者地址列表&lt;/li>
&lt;li>服务监控中心启动时，从 &lt;code>Channel:/dubbo/*&lt;/code> 订阅 &lt;code>register&lt;/code> 和 &lt;code>unregister&lt;/code>，以及 &lt;code>subscribe&lt;/code> 和&lt;code>unsubsribe &lt;/code>事件&lt;/li>
&lt;li>服务监控中心收到 &lt;code>register&lt;/code> 和 &lt;code>unregister&lt;/code> 事件后，从 &lt;code>Key:/dubbo/com.foo.BarService/providers&lt;/code> 下获取提供者地址列表&lt;/li>
&lt;li>服务监控中心收到 &lt;code>subscribe&lt;/code> 和 &lt;code>unsubsribe&lt;/code> 事件后，从 &lt;code>Key:/dubbo/com.foo.BarService/consumers&lt;/code> 下获取消费者地址列表&lt;/li>
&lt;/ol>
&lt;h2 id="配置">配置&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;redis://10.20.153.10:6379&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;redis://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;redis&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:6379&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#268bd2">&amp;lt;dubbo:registry&lt;/span> protocol=&lt;span style="color:#2aa198">&amp;#34;redis&amp;#34;&lt;/span> address=&lt;span style="color:#2aa198">&amp;#34;10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="选项">选项&lt;/h2>
&lt;ul>
&lt;li>可通过 &lt;code>&amp;lt;dubbo:registry group=&amp;quot;dubbo&amp;quot; /&amp;gt;&lt;/code> 设置 redis 中 key 的前缀，缺省为 &lt;code>dubbo&lt;/code>。&lt;/li>
&lt;li>可通过 &lt;code>&amp;lt;dubbo:registry cluster=&amp;quot;replicate&amp;quot; /&amp;gt;&lt;/code> 设置 redis 集群策略，缺省为 &lt;code>failover&lt;/code>：
&lt;ul>
&lt;li>&lt;code>failover&lt;/code>: 只写入和读取任意一台，失败时重试另一台，需要服务器端自行配置数据同步&lt;/li>
&lt;li>&lt;code>replicate&lt;/code>: 在客户端同时写入所有服务器，只读取单台，服务器端不需要同步，注册中心集群增大，性能压力也会更大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="可靠性声明">可靠性声明&lt;/h2>
&lt;p>阿里内部并没有采用 Redis 做为注册中心，而是使用自己实现的基于数据库的注册中心，即：Redis 注册中心并没有在阿里内部长时间运行的可靠性保障，此 Redis 桥接实现只为开源版本提供，其可靠性依赖于 Redis 本身的可靠性。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>安装方式参见: &lt;a href="../../../admin/install/redis.md">Redis安装手册&lt;/a>，只需搭一个原生的 Redis 服务器，并将 &lt;a href="../../preface/usage.md">Quick Start&lt;/a> 中 Provider 和 Consumer 里的 &lt;code>conf/dubbo.properties&lt;/code> 中的 &lt;code>dubbo.registry.address&lt;/code> 的值改为 &lt;code>redis://127.0.0.1:6379&lt;/code> 即可使用。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="http://redis.io">Redis&lt;/a> 是一个高效的 KV 存储服务器 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>